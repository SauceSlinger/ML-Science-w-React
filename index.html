<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Science Explorer - Interactive Machine Learning Guide</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // ===== DATA GENERATORS =====
        const utils = {
            randomNormal: (mean = 0, std = 1) => {
                const u = Math.random();
                const v = Math.random();
                return mean + std * Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            },
            
            randomBetween: (min, max) => Math.random() * (max - min) + min,
            
            addNoise: (value, noiseLevel = 0.1) => {
                return value + utils.randomNormal(0, noiseLevel);
            }
        };

        const generateVineyardData = (samples = 200) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const rainfall = utils.randomBetween(15, 45);
                const temperature = utils.randomBetween(55, 75);
                const soilPH = utils.randomBetween(5.5, 8.0);
                
                const baseYield = 2 * rainfall + 1.5 * temperature - 3 * soilPH + 20;
                const yield_tons = Math.max(0, utils.addNoise(baseYield, 2));
                
                data.push({
                    id: i + 1,
                    rainfall: Math.round(rainfall * 10) / 10,
                    temperature: Math.round(temperature * 10) / 10,
                    soilPH: Math.round(soilPH * 100) / 100,
                    yield_tons: Math.round(yield_tons * 10) / 10,
                    year: 2015 + (i % 9)
                });
            }
            
            return data;
        };

        const generateDragonEggData = (samples = 300) => {
            const data = [];
            const eggTypes = ['Fire', 'Ice', 'Earth', 'Air', 'Shadow', 'Light'];
            
            for (let i = 0; i < samples; i++) {
                const eggType = eggTypes[Math.floor(Math.random() * eggTypes.length)];
                
                // Each egg type has different optimal conditions
                let baseTemp, tempVariance, auraBonus, hatchBonus;
                switch(eggType) {
                    case 'Fire':
                        baseTemp = 1350; tempVariance = 50; auraBonus = 0.8; hatchBonus = 0.3;
                        break;
                    case 'Ice':
                        baseTemp = 1050; tempVariance = 40; auraBonus = 0.6; hatchBonus = 0.2;
                        break;
                    case 'Earth':
                        baseTemp = 1200; tempVariance = 60; auraBonus = 0.4; hatchBonus = 0.1;
                        break;
                    case 'Air':
                        baseTemp = 1250; tempVariance = 70; auraBonus = 0.9; hatchBonus = 0.4;
                        break;
                    case 'Shadow':
                        baseTemp = 1100; tempVariance = 30; auraBonus = 1.2; hatchBonus = 0.6;
                        break;
                    case 'Light':
                        baseTemp = 1300; tempVariance = 45; auraBonus = 1.0; hatchBonus = 0.5;
                        break;
                }
                
                const temperature = Math.max(950, Math.min(1450, 
                    utils.randomNormal(baseTemp, tempVariance)));
                const magicalAura = Math.max(0, Math.min(100, 
                    utils.randomNormal(50 + auraBonus * 20, 15)));
                const incubationDays = Math.floor(utils.randomBetween(30, 120));
                const dragonAge = Math.floor(utils.randomBetween(500, 5000)); // Age of parent dragon
                const moonPhase = ['New', 'Waxing', 'Full', 'Waning'][Math.floor(Math.random() * 4)];
                
                // Enhanced logistic regression with more realistic parameters
                const tempOptimal = Math.abs(temperature - baseTemp) < tempVariance ? 1 : 0.3;
                const auraEffect = magicalAura / 100;
                const incubationEffect = Math.max(0, (90 - incubationDays) / 60);
                const ageEffect = Math.min(1, dragonAge / 2000); // Older dragons = better eggs
                const moonBonus = moonPhase === 'Full' ? 0.3 : 0;
                
                const logit = -2 + 
                    (tempOptimal * 3) + 
                    (auraEffect * 2) + 
                    (incubationEffect * 1.5) + 
                    (ageEffect * 1) + 
                    moonBonus + 
                    hatchBonus;
                
                const hatchProbability = 1 / (1 + Math.exp(-logit));
                const hatched = Math.random() < hatchProbability;
                
                data.push({
                    id: i + 1,
                    temperature: Math.round(temperature),
                    magicalAura: Math.round(magicalAura * 10) / 10,
                    incubationDays,
                    eggType,
                    dragonAge,
                    moonPhase,
                    hatched,
                    hatchProbability: Math.round(hatchProbability * 100) / 100,
                    expectedHatchTime: hatched ? Math.floor(utils.randomBetween(incubationDays - 10, incubationDays + 5)) : null
                });
            }
            
            return data;
        };

        const generateRetailCustomerData = (samples = 300) => {
            const data = [];
            const segments = [
                { name: 'Budget Buyers', avgSpend: 50, frequency: 2 },
                { name: 'Luxury Seekers', avgSpend: 300, frequency: 1 },
                { name: 'Impulse Shoppers', avgSpend: 120, frequency: 4 },
                { name: 'Regular Shoppers', avgSpend: 80, frequency: 3 },
                { name: 'Occasion Buyers', avgSpend: 200, frequency: 0.5 }
            ];
            
            for (let i = 0; i < samples; i++) {
                const segment = segments[Math.floor(Math.random() * segments.length)];
                
                const monthlySpend = Math.max(10, utils.randomNormal(segment.avgSpend, segment.avgSpend * 0.3));
                const purchaseFrequency = Math.max(0.1, utils.randomNormal(segment.frequency, segment.frequency * 0.4));
                const sessionDuration = utils.randomBetween(2, 45);
                const itemsPerPurchase = Math.max(1, Math.floor(utils.randomNormal(3, 2)));
                
                data.push({
                    id: i + 1,
                    monthlySpend: Math.round(monthlySpend),
                    purchaseFrequency: Math.round(purchaseFrequency * 10) / 10,
                    sessionDuration: Math.round(sessionDuration),
                    itemsPerPurchase,
                    segment: segment.name,
                    age: Math.floor(utils.randomBetween(18, 70)),
                    membershipYears: Math.floor(utils.randomBetween(0, 10))
                });
            }
            
            return data;
        };

        // Additional data generators for all 16 examples
        const generateStreamingData = (samples = 500) => {
            const data = [];
            const timeSlots = ['morning', 'afternoon', 'evening', 'night'];
            const devices = ['phone', 'tablet', 'laptop', 'tv'];
            const genres = ['action', 'comedy', 'drama', 'documentary', 'horror', 'romance'];
            
            for (let i = 0; i < samples; i++) {
                const timeOfDay = timeSlots[Math.floor(Math.random() * timeSlots.length)];
                const device = devices[Math.floor(Math.random() * devices.length)];
                const weekday = Math.random() > 0.3;
                const previousGenre = genres[Math.floor(Math.random() * genres.length)];
                const watchTime = Math.floor(utils.randomBetween(10, 180));
                
                let recommendedGenre;
                if (timeOfDay === 'morning' && weekday) {
                    recommendedGenre = Math.random() > 0.6 ? 'documentary' : 'comedy';
                } else if (timeOfDay === 'evening' && device === 'tv') {
                    recommendedGenre = Math.random() > 0.5 ? 'action' : 'drama';
                } else if (timeOfDay === 'night') {
                    recommendedGenre = Math.random() > 0.7 ? 'horror' : 'romance';
                } else {
                    recommendedGenre = genres[Math.floor(Math.random() * genres.length)];
                }
                
                data.push({
                    id: i + 1,
                    timeOfDay,
                    device,
                    weekday,
                    previousGenre,
                    watchTime,
                    recommendedGenre
                });
            }
            return data;
        };

        const generateInsuranceData = (samples = 400) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const claimAmount = utils.randomBetween(500, 50000);
                const policyAge = Math.floor(utils.randomBetween(1, 120));
                const claimsHistory = Math.floor(utils.randomBetween(0, 5));
                const timeToReport = Math.floor(utils.randomBetween(0, 30));
                const witnessCount = Math.floor(utils.randomBetween(0, 4));
                
                let fraudScore = 0;
                if (claimAmount > 30000) fraudScore += 0.3;
                if (timeToReport > 14) fraudScore += 0.2;
                if (claimsHistory >= 3) fraudScore += 0.25;
                if (witnessCount === 0) fraudScore += 0.15;
                if (policyAge < 6) fraudScore += 0.1;
                
                const isFraud = fraudScore > 0.5 && Math.random() > 0.3;
                
                data.push({
                    id: i + 1,
                    claimAmount: Math.round(claimAmount),
                    policyAge,
                    claimsHistory,
                    timeToReport,
                    witnessCount,
                    isFraud,
                    fraudScore: Math.round(fraudScore * 100) / 100
                });
            }
            return data;
        };

        const generateAsteroidData = (samples = 150) => {
            const data = [];
            const asteroidTypes = ['metallic', 'rocky', 'icy'];
            
            for (let i = 0; i < samples; i++) {
                const asteroidType = asteroidTypes[Math.floor(Math.random() * asteroidTypes.length)];
                
                let feature1, feature2, feature3, feature4;
                
                if (asteroidType === 'metallic') {
                    feature1 = utils.randomNormal(0.8, 0.1);
                    feature2 = utils.randomNormal(0.3, 0.05);
                    feature3 = utils.randomNormal(0.9, 0.08);
                    feature4 = utils.randomNormal(0.2, 0.03);
                } else if (asteroidType === 'rocky') {
                    feature1 = utils.randomNormal(0.4, 0.08);
                    feature2 = utils.randomNormal(0.7, 0.1);
                    feature3 = utils.randomNormal(0.3, 0.06);
                    feature4 = utils.randomNormal(0.1, 0.02);
                } else {
                    feature1 = utils.randomNormal(0.2, 0.05);
                    feature2 = utils.randomNormal(0.5, 0.08);
                    feature3 = utils.randomNormal(0.1, 0.03);
                    feature4 = utils.randomNormal(0.8, 0.1);
                }
                
                data.push({
                    id: i + 1,
                    asteroidType,
                    spectralFeature1: Math.max(0, Math.min(1, feature1)),
                    spectralFeature2: Math.max(0, Math.min(1, feature2)),
                    spectralFeature3: Math.max(0, Math.min(1, feature3)),
                    spectralFeature4: Math.max(0, Math.min(1, feature4)),
                    distance: utils.randomBetween(1, 100),
                    diameter: utils.randomBetween(10, 1000)
                });
            }
            return data;
        };

        const generateMedicalImageData = (samples = 250) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const hasTumor = Math.random() > 0.7;
                
                const brightness = utils.randomNormal(hasTumor ? 0.3 : 0.5, 0.1);
                const contrast = utils.randomNormal(hasTumor ? 0.7 : 0.4, 0.1);
                const edgeSharpness = utils.randomNormal(hasTumor ? 0.8 : 0.3, 0.08);
                const asymmetry = utils.randomNormal(hasTumor ? 0.6 : 0.2, 0.1);
                
                const confidence = hasTumor ? 
                    utils.randomBetween(0.7, 0.95) : 
                    utils.randomBetween(0.1, 0.4);
                
                data.push({
                    id: i + 1,
                    patientAge: Math.floor(utils.randomBetween(25, 85)),
                    brightness: Math.max(0, Math.min(1, brightness)),
                    contrast: Math.max(0, Math.min(1, contrast)),
                    edgeSharpness: Math.max(0, Math.min(1, edgeSharpness)),
                    asymmetry: Math.max(0, Math.min(1, asymmetry)),
                    hasTumor,
                    confidence: Math.round(confidence * 100) / 100,
                    imageType: ['xray', 'mri', 'ct'][Math.floor(Math.random() * 3)]
                });
            }
            return data;
        };

        const generateEvolutionaryData = (samples = 50) => {
            const species = [
                'Human', 'Chimpanzee', 'Gorilla', 'Orangutan', 'Gibbon',
                'Dog', 'Wolf', 'Fox', 'Cat', 'Lion', 'Tiger',
                'Mouse', 'Rat', 'Rabbit', 'Cow', 'Horse', 'Pig',
                'Chicken', 'Duck', 'Eagle', 'Salmon', 'Tuna', 'Shark'
            ];
            
            const data = [];
            
            for (let i = 0; i < Math.min(samples, species.length); i++) {
                const dnaSequence1 = utils.randomBetween(0, 1);
                const dnaSequence2 = utils.randomBetween(0, 1);
                const dnaSequence3 = utils.randomBetween(0, 1);
                const dnaSequence4 = utils.randomBetween(0, 1);
                const dnaSequence5 = utils.randomBetween(0, 1);
                
                data.push({
                    id: i + 1,
                    species: species[i],
                    dnaSequence1: Math.round(dnaSequence1 * 1000) / 1000,
                    dnaSequence2: Math.round(dnaSequence2 * 1000) / 1000,
                    dnaSequence3: Math.round(dnaSequence3 * 1000) / 1000,
                    dnaSequence4: Math.round(dnaSequence4 * 1000) / 1000,
                    dnaSequence5: Math.round(dnaSequence5 * 1000) / 1000,
                    category: i < 5 ? 'Primates' : 
                             i < 11 ? 'Carnivores' : 
                             i < 17 ? 'Herbivores' : 
                             i < 20 ? 'Birds' : 'Fish'
                });
            }
            return data;
        };

        const generateWarehouseData = (samples = 100) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const startX = Math.floor(utils.randomBetween(0, 10));
                const startY = Math.floor(utils.randomBetween(0, 10));
                const goalX = Math.floor(utils.randomBetween(0, 10));
                const goalY = Math.floor(utils.randomBetween(0, 10));
                
                const optimalSteps = Math.abs(goalX - startX) + Math.abs(goalY - startY);
                const actualSteps = optimalSteps + Math.floor(utils.randomBetween(0, 5));
                const reward = 100 - (actualSteps - optimalSteps) * 10;
                
                data.push({
                    id: i + 1,
                    startX,
                    startY,
                    goalX,
                    goalY,
                    optimalSteps,
                    actualSteps,
                    reward,
                    obstacles: Math.floor(utils.randomBetween(0, 8)),
                    completionTime: Math.round((actualSteps * 2 + utils.randomBetween(0, 10)) * 10) / 10
                });
            }
            return data;
        };

        const generateRacingAIData = (samples = 1000) => {
            const data = [];
            const tracks = ['Monaco', 'Silverstone', 'Spa', 'Nurburgring', 'Monza', 'Suzuka'];
            const difficulties = ['Beginner', 'Amateur', 'Professional', 'Expert'];
            const carTypes = ['Formula', 'GT', 'Rally', 'Endurance'];
            
            // Simulate training progression over time
            for (let episode = 1; episode <= samples; episode++) {
                const track = tracks[Math.floor(Math.random() * tracks.length)];
                const carType = carTypes[Math.floor(Math.random() * carTypes.length)];
                const difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
                
                // Training progression - AI gets better over time
                const trainingProgress = episode / samples;
                const experienceBonus = Math.log(1 + episode / 100) / 5;
                
                // Track-specific base lap times (in seconds)
                const baseTime = {
                    'Monaco': 78, 'Silverstone': 90, 'Spa': 106,
                    'Nurburgring': 425, 'Monza': 81, 'Suzuka': 130
                }[track];
                
                // Difficulty multipliers for opponent strength
                const difficultyMultiplier = {
                    'Beginner': 0.7, 'Amateur': 0.85, 'Professional': 1.0, 'Expert': 1.15
                }[difficulty];
                
                // Car type performance modifiers
                const carModifier = {
                    'Formula': 1.0, 'GT': 1.08, 'Rally': 1.12, 'Endurance': 1.05
                }[carType];
                
                // AI lap time improves with training
                const aiSkillFactor = 1.2 - (trainingProgress * 0.3) - experienceBonus;
                const aiLapTime = baseTime * aiSkillFactor * carModifier;
                
                // Human opponent lap time (relatively stable)
                const humanSkillVariance = utils.randomNormal(1.0, 0.08);
                const humanLapTime = baseTime * difficultyMultiplier * humanSkillVariance * carModifier;
                
                // Race outcome based on lap time comparison
                const aiWon = aiLapTime < humanLapTime;
                const timeDifference = Math.abs(aiLapTime - humanLapTime);
                
                // Q-values for different actions (simplified)
                const accelerateQ = utils.randomNormal(0.7 + trainingProgress * 0.5, 0.1);
                const brakeQ = utils.randomNormal(0.4 + trainingProgress * 0.3, 0.1);
                const turnLeftQ = utils.randomNormal(0.5 + trainingProgress * 0.4, 0.1);
                const turnRightQ = utils.randomNormal(0.5 + trainingProgress * 0.4, 0.1);
                const overtakeQ = utils.randomNormal(0.2 + trainingProgress * 0.6, 0.1);
                
                // Reward calculation (DQN reward function)
                let reward = 0;
                if (aiWon) {
                    reward = 100 - (timeDifference * 2); // Bonus for winning, bigger bonus for dominant wins
                } else {
                    reward = -50 + Math.max(0, 30 - timeDifference); // Penalty for losing, less penalty for close races
                }
                
                // Exploration vs exploitation (epsilon-greedy)
                const epsilon = Math.max(0.01, 0.9 * Math.exp(-episode / 200)); // Decay exploration over time
                const wasRandomAction = Math.random() < epsilon;
                
                // Crashes and mistakes decrease with training
                const crashProbability = Math.max(0.001, 0.1 * Math.exp(-episode / 150));
                const crashed = Math.random() < crashProbability;
                
                // Track position and speed data
                const averageSpeed = utils.randomNormal(
                    280 + (trainingProgress * 40) - (crashed ? 50 : 0), 
                    15
                );
                const maxSpeed = averageSpeed * utils.randomBetween(1.15, 1.25);
                const cornersOptimal = Math.round((trainingProgress * 85 + 15) + utils.randomNormal(0, 5));
                
                data.push({
                    id: episode,
                    episode: episode,
                    track: track,
                    carType: carType,
                    difficulty: difficulty,
                    aiLapTime: Math.round(aiLapTime * 1000) / 1000,
                    humanLapTime: Math.round(humanLapTime * 1000) / 1000,
                    timeDifference: Math.round(timeDifference * 1000) / 1000,
                    aiWon: aiWon,
                    reward: Math.round(reward * 10) / 10,
                    epsilon: Math.round(epsilon * 1000) / 1000,
                    wasRandomAction: wasRandomAction,
                    crashed: crashed,
                    averageSpeed: Math.round(averageSpeed),
                    maxSpeed: Math.round(maxSpeed),
                    cornersOptimal: Math.max(0, Math.min(100, cornersOptimal)),
                    accelerateQ: Math.round(accelerateQ * 1000) / 1000,
                    brakeQ: Math.round(brakeQ * 1000) / 1000,
                    turnLeftQ: Math.round(turnLeftQ * 1000) / 1000,
                    turnRightQ: Math.round(turnRightQ * 1000) / 1000,
                    overtakeQ: Math.round(overtakeQ * 1000) / 1000,
                    trainingProgress: Math.round(trainingProgress * 1000) / 1000,
                    cumulativeReward: 0 // Will be calculated after all data is generated
                });
            }
            
            // Calculate cumulative rewards
            let cumulativeSum = 0;
            data.forEach(race => {
                cumulativeSum += race.reward;
                race.cumulativeReward = Math.round(cumulativeSum * 10) / 10;
            });
            
            return data;
        };

        const generateEnergyGridData = (samples = 2000) => {
            const data = [];
            
            // Simulate 24-hour cycles over multiple days for realistic energy patterns
            const hoursPerDay = 24;
            const daysToSimulate = Math.ceil(samples / hoursPerDay);
            
            for (let day = 0; day < daysToSimulate; day++) {
                for (let hour = 0; hour < hoursPerDay && data.length < samples; hour++) {
                    const timestamp = day * 24 + hour;
                    const hourOfDay = hour;
                    const dayOfWeek = day % 7; // 0=Monday, 6=Sunday
                    const isWeekend = dayOfWeek >= 5;
                    const season = Math.floor((day % 365) / 91); // 0=Spring, 1=Summer, 2=Fall, 3=Winter
                    
                    // Weather simulation - affects renewable generation
                    const baseCloudiness = utils.randomNormal(0.4, 0.2);
                    const cloudiness = Math.max(0, Math.min(1, baseCloudiness));
                    const windSpeed = Math.max(0, utils.randomNormal(15 + Math.sin(hour / 24 * Math.PI * 2) * 5, 8)); // mph
                    const temperature = 70 + Math.sin(hour / 24 * Math.PI * 2) * 20 + (season === 1 ? 10 : season === 3 ? -15 : 0);
                    
                    // Energy demand patterns (realistic daily curves)
                    let baseDemand;
                    if (hourOfDay >= 6 && hourOfDay <= 9) { // Morning peak
                        baseDemand = 800 + (hourOfDay - 6) * 100;
                    } else if (hourOfDay >= 17 && hourOfDay <= 20) { // Evening peak
                        baseDemand = 900 + (hourOfDay - 17) * 80;
                    } else if (hourOfDay >= 22 || hourOfDay <= 5) { // Night low
                        baseDemand = 400 + Math.random() * 100;
                    } else { // Day moderate
                        baseDemand = 600 + Math.random() * 200;
                    }
                    
                    // Weekend and seasonal adjustments
                    if (isWeekend) baseDemand *= 0.85; // Lower weekend demand
                    if (season === 1) baseDemand *= 1.3; // Higher summer demand (AC)
                    if (season === 3) baseDemand *= 1.2; // Higher winter demand (heating)
                    
                    const energyDemand = Math.round(baseDemand);
                    
                    // Renewable energy generation capacity (weather dependent)
                    const solarCapacity = Math.max(0, (1 - cloudiness) * Math.sin(Math.max(0, (hourOfDay - 6) / 12) * Math.PI) * 1000);
                    const windCapacity = Math.min(800, Math.pow(windSpeed / 25, 1.5) * 800);
                    const hydroCapacity = 300; // Constant baseload
                    const totalRenewableCapacity = solarCapacity + windCapacity + hydroCapacity;
                    
                    // Policy Gradient learning - continuous action space [0,1] for each source
                    const trainingProgress = Math.min(1, timestamp / (samples * 0.7));
                    
                    // Policy network outputs (learned over time)
                    const policyImprovement = trainingProgress * 0.4;
                    
                    // Solar allocation policy (0-100%)
                    const solarPolicy = Math.max(0, Math.min(1, 
                        0.3 + policyImprovement + (solarCapacity > 0 ? 0.4 : -0.2) + utils.randomNormal(0, 0.1)
                    ));
                    
                    // Wind allocation policy (0-100%)
                    const windPolicy = Math.max(0, Math.min(1,
                        0.25 + policyImprovement + (windCapacity > 200 ? 0.3 : -0.1) + utils.randomNormal(0, 0.1)
                    ));
                    
                    // Battery usage policy (-100% to +100%, negative = charging, positive = discharging)
                    const batteryStorageLevel = 0.6; // Assume 60% charged for simplicity
                    let batteryPolicy;
                    if (energyDemand > totalRenewableCapacity * 0.8) {
                        batteryPolicy = Math.max(-1, Math.min(1, 0.6 + policyImprovement)); // Discharge when demand high
                    } else {
                        batteryPolicy = Math.max(-1, Math.min(1, -0.4 - policyImprovement)); // Charge when excess
                    }
                    
                    // Grid purchases from conventional sources (last resort)
                    const solarGeneration = solarCapacity * solarPolicy;
                    const windGeneration = windCapacity * windPolicy;
                    const hydroGeneration = hydroCapacity; // Always on
                    const batteryContribution = batteryPolicy > 0 ? batteryPolicy * 400 : 0; // 400MW max discharge
                    const totalRenewableGeneration = solarGeneration + windGeneration + hydroGeneration + batteryContribution;
                    
                    const gridPurchases = Math.max(0, energyDemand - totalRenewableGeneration);
                    const excessEnergy = Math.max(0, totalRenewableGeneration - energyDemand);
                    
                    // Cost calculation (Policy Gradient reward function)
                    const solarCost = solarGeneration * 0.05; // $0.05/MWh
                    const windCost = windGeneration * 0.03; // $0.03/MWh  
                    const hydroCost = hydroGeneration * 0.02; // $0.02/MWh
                    const batteryCost = Math.abs(batteryPolicy) * 20; // Battery wear cost
                    const gridCost = gridPurchases * 0.12; // $0.12/MWh (expensive)
                    const wastePeralty = excessEnergy * 0.08; // Penalty for excess
                    
                    const totalCost = solarCost + windCost + hydroCost + batteryCost + gridCost + wastePeralty;
                    
                    // Policy Gradient reward (negative cost + carbon benefits)
                    const carbonOffset = (solarGeneration + windGeneration + hydroGeneration) * 0.001; // Carbon benefit
                    const reward = -totalCost + carbonOffset + (gridPurchases === 0 ? 50 : 0); // Bonus for 100% renewable
                    
                    // Policy gradient metrics
                    const policyEntropy = -(solarPolicy * Math.log(solarPolicy + 0.001) + 
                                           windPolicy * Math.log(windPolicy + 0.001)) / 2; // Policy diversity
                    
                    const renewablePercentage = ((totalRenewableGeneration - batteryContribution) / energyDemand) * 100;
                    
                    data.push({
                        id: timestamp + 1,
                        timestamp: timestamp,
                        hour: hourOfDay,
                        dayOfWeek: dayOfWeek,
                        isWeekend: isWeekend,
                        season: ['Spring', 'Summer', 'Fall', 'Winter'][season],
                        cloudiness: Math.round(cloudiness * 100) / 100,
                        windSpeed: Math.round(windSpeed * 10) / 10,
                        temperature: Math.round(temperature * 10) / 10,
                        energyDemand: energyDemand,
                        solarCapacity: Math.round(solarCapacity),
                        windCapacity: Math.round(windCapacity),
                        hydroCapacity: Math.round(hydroCapacity),
                        solarPolicy: Math.round(solarPolicy * 1000) / 1000,
                        windPolicy: Math.round(windPolicy * 1000) / 1000,
                        batteryPolicy: Math.round(batteryPolicy * 1000) / 1000,
                        solarGeneration: Math.round(solarGeneration),
                        windGeneration: Math.round(windGeneration),
                        hydroGeneration: Math.round(hydroGeneration),
                        batteryContribution: Math.round(batteryContribution),
                        totalRenewableGeneration: Math.round(totalRenewableGeneration),
                        gridPurchases: Math.round(gridPurchases),
                        excessEnergy: Math.round(excessEnergy),
                        totalCost: Math.round(totalCost * 100) / 100,
                        reward: Math.round(reward * 100) / 100,
                        renewablePercentage: Math.round(renewablePercentage * 10) / 10,
                        policyEntropy: Math.round(policyEntropy * 1000) / 1000,
                        trainingProgress: Math.round(trainingProgress * 1000) / 1000
                    });
                }
            }
            
            // Calculate cumulative metrics
            let cumulativeCost = 0;
            let cumulativeReward = 0;
            data.forEach(record => {
                cumulativeCost += record.totalCost;
                cumulativeReward += record.reward;
                record.cumulativeCost = Math.round(cumulativeCost * 100) / 100;
                record.cumulativeReward = Math.round(cumulativeReward * 100) / 100;
            });
            
            return data;
        };

        const generateArtCompressorData = (samples = 500) => {
            const data = [];
            
            // Art style categories for realistic dataset
            const artStyles = [
                'Renaissance', 'Baroque', 'Impressionist', 'Abstract', 'Cubist', 
                'Surrealist', 'Pop Art', 'Minimalist', 'Expressionist', 'Contemporary'
            ];
            
            const artists = [
                'Da Vinci', 'Picasso', 'Van Gogh', 'Monet', 'Dal√≠', 
                'Warhol', 'Pollock', 'Kandinsky', 'Matisse', 'Rothko'
            ];
            
            const mediums = ['Oil', 'Acrylic', 'Watercolor', 'Digital', 'Mixed Media'];
            
            for (let i = 0; i < samples; i++) {
                const artStyle = artStyles[Math.floor(Math.random() * artStyles.length)];
                const artist = artists[Math.floor(Math.random() * artists.length)];
                const medium = mediums[Math.floor(Math.random() * mediums.length)];
                
                // Generate 2048 original features (simulating CNN features from artwork analysis)
                const originalFeatures = Array.from({ length: 2048 }, () => 
                    Math.random() * 2 - 1 // Values between -1 and 1
                );
                
                // Simulate PCA compression to 10 principal components
                // Each PC captures different style aspects with decreasing variance
                const pc1 = originalFeatures.slice(0, 200).reduce((sum, val) => sum + val, 0) / 200 + 
                           (artStyle === 'Renaissance' ? 0.8 : artStyle === 'Abstract' ? -0.7 : Math.random() * 0.4 - 0.2);
                           
                const pc2 = originalFeatures.slice(200, 400).reduce((sum, val) => sum + val, 0) / 200 + 
                           (artStyle === 'Impressionist' ? 0.9 : artStyle === 'Cubist' ? -0.8 : Math.random() * 0.3 - 0.15);
                           
                const pc3 = originalFeatures.slice(400, 600).reduce((sum, val) => sum + val, 0) / 200 + 
                           (medium === 'Digital' ? 0.6 : medium === 'Oil' ? -0.5 : Math.random() * 0.3 - 0.15);
                           
                const pc4 = originalFeatures.slice(600, 800).reduce((sum, val) => sum + val, 0) / 200 + 
                           (artStyle === 'Pop Art' ? 0.7 : artStyle === 'Minimalist' ? -0.6 : Math.random() * 0.25 - 0.125);
                           
                const pc5 = originalFeatures.slice(800, 1000).reduce((sum, val) => sum + val, 0) / 200 + 
                           Math.random() * 0.4 - 0.2;
                           
                const pc6 = originalFeatures.slice(1000, 1200).reduce((sum, val) => sum + val, 0) / 200 + 
                           Math.random() * 0.3 - 0.15;
                           
                const pc7 = originalFeatures.slice(1200, 1400).reduce((sum, val) => sum + val, 0) / 200 + 
                           Math.random() * 0.25 - 0.125;
                           
                const pc8 = originalFeatures.slice(1400, 1600).reduce((sum, val) => sum + val, 0) / 200 + 
                           Math.random() * 0.2 - 0.1;
                           
                const pc9 = originalFeatures.slice(1600, 1800).reduce((sum, val) => sum + val, 0) / 200 + 
                           Math.random() * 0.15 - 0.075;
                           
                const pc10 = originalFeatures.slice(1800, 2000).reduce((sum, val) => sum + val, 0) / 200 + 
                            Math.random() * 0.1 - 0.05;
                
                // Calculate explained variance for each PC (decreasing)
                const explainedVariance = [
                    32.4, 18.7, 12.3, 8.9, 6.2, 4.8, 3.7, 2.9, 2.4, 1.9
                ];
                
                // Cumulative variance explained
                const cumulativeVariance = explainedVariance.reduce((acc, curr, idx) => {
                    acc.push((acc[idx - 1] || 0) + curr);
                    return acc;
                }, []);
                
                // Reconstruction error (lower for well-represented styles)
                const reconstructionError = Math.max(0.02, 
                    0.15 - (cumulativeVariance[9] / 100) + Math.random() * 0.08
                );
                
                // Similarity score for style matching (0-1)
                const similarityScore = Math.max(0.1, 
                    0.95 - reconstructionError * 2 + Math.random() * 0.1
                );
                
                // Search efficiency improvement
                const searchSpeedUp = Math.round(2048 / 10 * (0.8 + Math.random() * 0.4));
                
                data.push({
                    artworkId: `ART-${String(i + 1).padStart(4, '0')}`,
                    artStyle,
                    artist,
                    medium,
                    originalDimensions: 2048,
                    compressedDimensions: 10,
                    pc1: Math.round(pc1 * 1000) / 1000,
                    pc2: Math.round(pc2 * 1000) / 1000,
                    pc3: Math.round(pc3 * 1000) / 1000,
                    pc4: Math.round(pc4 * 1000) / 1000,
                    pc5: Math.round(pc5 * 1000) / 1000,
                    pc6: Math.round(pc6 * 1000) / 1000,
                    pc7: Math.round(pc7 * 1000) / 1000,
                    pc8: Math.round(pc8 * 1000) / 1000,
                    pc9: Math.round(pc9 * 1000) / 1000,
                    pc10: Math.round(pc10 * 1000) / 1000,
                    explainedVarianceRatio: explainedVariance,
                    cumulativeVariance: Math.round(cumulativeVariance[9] * 10) / 10,
                    reconstructionError: Math.round(reconstructionError * 1000) / 1000,
                    similarityScore: Math.round(similarityScore * 1000) / 1000,
                    searchSpeedUp,
                    compressionRatio: Math.round((1 - 10/2048) * 1000) / 10, // 99.5%
                    storageReduction: Math.round((2048 - 10) / 2048 * 100 * 10) / 10
                });
            }
            
            return data;
        };

        const generateQuantumDenoisingData = (samples = 800) => {
            const data = [];
            
            // Quantum measurement types and their characteristics
            const measurementTypes = [
                'Spin-Up', 'Spin-Down', 'Entangled Pair', 'Superposition', 'Coherent State'
            ];
            
            const noiseTypes = [
                'Thermal', 'Shot', 'Phase', 'Amplitude', 'Environmental'
            ];
            
            const detectorTypes = ['SQUID', 'Single-Photon', 'Ion Trap', 'NV Center', 'Josephson Junction'];
            
            for (let i = 0; i < samples; i++) {
                const measurementType = measurementTypes[Math.floor(Math.random() * measurementTypes.length)];
                const noiseType = noiseTypes[Math.floor(Math.random() * noiseTypes.length)];
                const detectorType = detectorTypes[Math.floor(Math.random() * detectorTypes.length)];
                
                // Generate quantum signal components using GMM principles
                // Component 1: Pure quantum signal (highest probability, low noise)
                const signalStrength = measurementType === 'Entangled Pair' ? 0.85 + Math.random() * 0.1 :
                                     measurementType === 'Coherent State' ? 0.75 + Math.random() * 0.15 :
                                     measurementType === 'Superposition' ? 0.65 + Math.random() * 0.2 :
                                     0.5 + Math.random() * 0.3;
                
                // Component 2: Noise-corrupted signal (medium probability, higher variance)
                const noiseLevel = noiseType === 'Thermal' ? 0.15 + Math.random() * 0.25 :
                                  noiseType === 'Shot' ? 0.1 + Math.random() * 0.2 :
                                  noiseType === 'Phase' ? 0.2 + Math.random() * 0.3 :
                                  noiseType === 'Environmental' ? 0.25 + Math.random() * 0.35 :
                                  0.05 + Math.random() * 0.15; // Amplitude noise
                
                // Component 3: Pure noise (lowest probability, highest variance)
                const pureNoise = Math.random() * 0.4;
                
                // GMM component weights (probabilities)
                const componentWeights = {
                    signal: 0.6 + Math.random() * 0.25,  // 60-85% signal
                    corruptedSignal: 0.15 + Math.random() * 0.2,  // 15-35% corrupted
                    noise: 0.05 + Math.random() * 0.15   // 5-20% pure noise
                };
                
                // Normalize weights
                const totalWeight = componentWeights.signal + componentWeights.corruptedSignal + componentWeights.noise;
                componentWeights.signal /= totalWeight;
                componentWeights.corruptedSignal /= totalWeight;
                componentWeights.noise /= totalWeight;
                
                // GMM component assignment (which component this measurement belongs to)
                const rand = Math.random();
                let assignedComponent;
                if (rand < componentWeights.signal) {
                    assignedComponent = 'Pure Signal';
                } else if (rand < componentWeights.signal + componentWeights.corruptedSignal) {
                    assignedComponent = 'Corrupted Signal';
                } else {
                    assignedComponent = 'Noise';
                }
                
                // Generate quantum measurement features
                // Amplitude and phase measurements (complex quantum states)
                const amplitude = assignedComponent === 'Pure Signal' ? signalStrength + Math.random() * 0.05 :
                                 assignedComponent === 'Corrupted Signal' ? signalStrength * (1 - noiseLevel) + Math.random() * noiseLevel :
                                 pureNoise + Math.random() * 0.1;
                
                const phase = assignedComponent === 'Pure Signal' ? (Math.PI / 4) + Math.random() * 0.1 - 0.05 :
                             assignedComponent === 'Corrupted Signal' ? (Math.PI / 4) + Math.random() * 0.4 - 0.2 :
                             Math.random() * 2 * Math.PI; // Random phase for noise
                
                // Coherence time (quantum decoherence)
                const coherenceTime = assignedComponent === 'Pure Signal' ? 10 + Math.random() * 5 :
                                     assignedComponent === 'Corrupted Signal' ? 5 + Math.random() * 3 :
                                     0.5 + Math.random() * 2;
                
                // Fidelity (quantum state purity)
                const fidelity = assignedComponent === 'Pure Signal' ? 0.95 + Math.random() * 0.04 :
                                assignedComponent === 'Corrupted Signal' ? 0.7 + Math.random() * 0.2 :
                                0.3 + Math.random() * 0.3;
                
                // Signal-to-noise ratio
                const snr = assignedComponent === 'Pure Signal' ? 25 + Math.random() * 10 :
                           assignedComponent === 'Corrupted Signal' ? 8 + Math.random() * 8 :
                           -5 + Math.random() * 5;
                
                // GMM log-likelihood for this measurement
                const logLikelihood = assignedComponent === 'Pure Signal' ? -2 + Math.random() * 1 :
                                     assignedComponent === 'Corrupted Signal' ? -8 + Math.random() * 3 :
                                     -15 + Math.random() * 5;
                
                // Temperature and environmental factors
                const temperature = 0.01 + Math.random() * 0.05; // Kelvin (near absolute zero)
                const magneticField = 0.1 + Math.random() * 2.0; // Tesla
                
                // Detector efficiency
                const detectorEfficiency = detectorType === 'SQUID' ? 0.95 + Math.random() * 0.04 :
                                          detectorType === 'Single-Photon' ? 0.85 + Math.random() * 0.1 :
                                          detectorType === 'NV Center' ? 0.75 + Math.random() * 0.15 :
                                          0.7 + Math.random() * 0.2;
                
                // Clustering metrics for GMM performance
                const clusterProbability = assignedComponent === 'Pure Signal' ? componentWeights.signal :
                                          assignedComponent === 'Corrupted Signal' ? componentWeights.corruptedSignal :
                                          componentWeights.noise;
                
                // Denoising quality metrics
                const denoisingQuality = assignedComponent === 'Pure Signal' ? 0.98 + Math.random() * 0.02 :
                                        assignedComponent === 'Corrupted Signal' ? 0.85 + Math.random() * 0.1 :
                                        0.4 + Math.random() * 0.3;
                
                const reconstructionError = assignedComponent === 'Pure Signal' ? Math.random() * 0.02 :
                                           assignedComponent === 'Corrupted Signal' ? 0.05 + Math.random() * 0.1 :
                                           0.2 + Math.random() * 0.3;
                
                data.push({
                    measurementId: `QM-${String(i + 1).padStart(4, '0')}`,
                    measurementType,
                    noiseType,
                    detectorType,
                    assignedComponent,
                    amplitude: Math.round(amplitude * 1000) / 1000,
                    phase: Math.round(phase * 1000) / 1000,
                    coherenceTime: Math.round(coherenceTime * 100) / 100,
                    fidelity: Math.round(fidelity * 1000) / 1000,
                    snr: Math.round(snr * 10) / 10,
                    logLikelihood: Math.round(logLikelihood * 100) / 100,
                    temperature: Math.round(temperature * 1000) / 1000,
                    magneticField: Math.round(magneticField * 100) / 100,
                    detectorEfficiency: Math.round(detectorEfficiency * 1000) / 1000,
                    clusterProbability: Math.round(clusterProbability * 1000) / 1000,
                    denoisingQuality: Math.round(denoisingQuality * 1000) / 1000,
                    reconstructionError: Math.round(reconstructionError * 1000) / 1000,
                    componentWeights,
                    signalStrength: Math.round(signalStrength * 1000) / 1000,
                    noiseLevel: Math.round(noiseLevel * 1000) / 1000
                });
            }
            
            return data;
        };

        const generateCrimeHotspotData = (samples = 600) => {
            const data = [];
            
            // Crime types with different clustering patterns
            const crimeTypes = [
                'Theft', 'Burglary', 'Assault', 'Vandalism', 'Drug Offense', 
                'Vehicle Crime', 'Robbery', 'Public Order', 'Fraud', 'Arson'
            ];
            
            // Time periods affecting crime patterns
            const timePeriods = ['Late Night', 'Early Morning', 'Afternoon', 'Evening', 'Weekend'];
            
            // Urban districts with different characteristics
            const districts = [
                'Downtown', 'Residential', 'Commercial', 'Industrial', 'Suburban',
                'Entertainment', 'Financial', 'University', 'Transit Hub', 'Park Area'
            ];
            
            // Define crime hotspot centers (latitude, longitude coordinates)
            // Simulating a city grid with known problem areas
            const hotspotCenters = [
                { lat: 40.7589, lng: -73.9851, type: 'High-Density Commercial', severity: 'High' },
                { lat: 40.7505, lng: -73.9934, type: 'Entertainment District', severity: 'High' },
                { lat: 40.7282, lng: -73.9942, type: 'Transit Hub', severity: 'Medium' },
                { lat: 40.7831, lng: -73.9712, type: 'Residential Complex', severity: 'Medium' },
                { lat: 40.7614, lng: -73.9776, type: 'Shopping Center', severity: 'Medium' },
                { lat: 40.7489, lng: -73.9680, type: 'University Area', severity: 'Low' },
                { lat: 40.7128, lng: -74.0060, type: 'Financial District', severity: 'Low' }
            ];
            
            // Generate clustered crime incidents around hotspots (70% of data)
            const clusteredIncidents = Math.floor(samples * 0.7);
            for (let i = 0; i < clusteredIncidents; i++) {
                const hotspot = hotspotCenters[Math.floor(Math.random() * hotspotCenters.length)];
                const crimeType = crimeTypes[Math.floor(Math.random() * crimeTypes.length)];
                const timePeriod = timePeriods[Math.floor(Math.random() * timePeriods.length)];
                const district = districts[Math.floor(Math.random() * districts.length)];
                
                // Generate coordinates clustered around hotspot center
                const clusterRadius = hotspot.severity === 'High' ? 0.008 : 
                                    hotspot.severity === 'Medium' ? 0.006 : 0.004;
                
                // Add random offset within cluster radius (normal distribution)
                const offsetLat = (Math.random() - 0.5) * clusterRadius * 2;
                const offsetLng = (Math.random() - 0.5) * clusterRadius * 2;
                
                const latitude = hotspot.lat + offsetLat;
                const longitude = hotspot.lng + offsetLng;
                
                // DBSCAN cluster assignment (will be determined by algorithm)
                const clusterDistance = Math.sqrt(offsetLat * offsetLat + offsetLng * offsetLng);
                const isCore = clusterDistance < clusterRadius * 0.6;
                const isBorder = clusterDistance < clusterRadius * 0.9 && !isCore;
                const clusterType = isCore ? 'Core' : isBorder ? 'Border' : 'Edge';
                
                // Crime severity based on type and location
                const severity = crimeType === 'Assault' || crimeType === 'Robbery' ? 'High' :
                               crimeType === 'Theft' || crimeType === 'Burglary' || crimeType === 'Vehicle Crime' ? 'Medium' :
                               'Low';
                
                // Time-based risk factors
                const riskFactor = timePeriod === 'Late Night' ? 0.9 :
                                  timePeriod === 'Weekend' ? 0.7 :
                                  timePeriod === 'Evening' ? 0.6 :
                                  0.4;
                
                // Response time based on location and severity
                const responseTime = severity === 'High' ? 3 + Math.random() * 5 :
                                   severity === 'Medium' ? 8 + Math.random() * 7 :
                                   15 + Math.random() * 10;
                
                // Population density (affects clustering density)
                const populationDensity = hotspot.type === 'High-Density Commercial' ? 15000 + Math.random() * 5000 :
                                        hotspot.type === 'Entertainment District' ? 12000 + Math.random() * 4000 :
                                        hotspot.type === 'Transit Hub' ? 8000 + Math.random() * 3000 :
                                        5000 + Math.random() * 2000;
                
                data.push({
                    incidentId: `CRIME-${String(i + 1).padStart(4, '0')}`,
                    latitude: Math.round(latitude * 10000) / 10000,
                    longitude: Math.round(longitude * 10000) / 10000,
                    crimeType,
                    timePeriod,
                    district,
                    severity,
                    hotspotCenter: hotspot.type,
                    clusterType,
                    clusterDistance: Math.round(clusterDistance * 100000) / 100000,
                    riskFactor: Math.round(riskFactor * 100) / 100,
                    responseTime: Math.round(responseTime * 10) / 10,
                    populationDensity: Math.round(populationDensity),
                    isNoise: false,
                    dbscanCluster: `Hotspot-${Math.floor(Math.random() * 7) + 1}`, // Simulated cluster assignment
                    neighborCount: isCore ? 8 + Math.floor(Math.random() * 12) : 
                                  isBorder ? 3 + Math.floor(Math.random() * 5) : 
                                  1 + Math.floor(Math.random() * 3),
                    corePointDistance: clusterDistance
                });
            }
            
            // Generate noise incidents (isolated crimes) - 30% of data
            const noiseIncidents = samples - clusteredIncidents;
            for (let i = 0; i < noiseIncidents; i++) {
                const crimeType = crimeTypes[Math.floor(Math.random() * crimeTypes.length)];
                const timePeriod = timePeriods[Math.floor(Math.random() * timePeriods.length)];
                const district = districts[Math.floor(Math.random() * districts.length)];
                
                // Random coordinates outside hotspot areas
                const latitude = 40.7000 + Math.random() * 0.1; // NYC area coordinates
                const longitude = -74.0200 + Math.random() * 0.1;
                
                // Ensure these are truly isolated (away from hotspots)
                let minDistanceToHotspot = Infinity;
                hotspotCenters.forEach(hotspot => {
                    const distance = Math.sqrt(
                        Math.pow(latitude - hotspot.lat, 2) + 
                        Math.pow(longitude - hotspot.lng, 2)
                    );
                    minDistanceToHotspot = Math.min(minDistanceToHotspot, distance);
                });
                
                // Only include if sufficiently far from hotspots
                if (minDistanceToHotspot > 0.015) {
                    const severity = crimeType === 'Assault' || crimeType === 'Robbery' ? 'High' :
                                   crimeType === 'Theft' || crimeType === 'Burglary' ? 'Medium' :
                                   'Low';
                    
                    const riskFactor = timePeriod === 'Late Night' ? 0.8 :
                                      timePeriod === 'Weekend' ? 0.6 :
                                      0.3;
                    
                    const responseTime = 20 + Math.random() * 15; // Longer response for isolated incidents
                    const populationDensity = 2000 + Math.random() * 3000; // Lower density areas
                    
                    data.push({
                        incidentId: `NOISE-${String(i + 1).padStart(4, '0')}`,
                        latitude: Math.round(latitude * 10000) / 10000,
                        longitude: Math.round(longitude * 10000) / 10000,
                        crimeType,
                        timePeriod,
                        district,
                        severity,
                        hotspotCenter: 'Isolated',
                        clusterType: 'Noise',
                        clusterDistance: minDistanceToHotspot,
                        riskFactor: Math.round(riskFactor * 100) / 100,
                        responseTime: Math.round(responseTime * 10) / 10,
                        populationDensity: Math.round(populationDensity),
                        isNoise: true,
                        dbscanCluster: 'Noise',
                        neighborCount: 0, // Isolated points have no neighbors
                        corePointDistance: minDistanceToHotspot
                    });
                }
            }
            
            // Calculate additional DBSCAN metrics
            data.forEach(incident => {
                // Density reachability score
                incident.densityScore = incident.isNoise ? 0 : 
                                       incident.clusterType === 'Core' ? 0.9 + Math.random() * 0.1 :
                                       incident.clusterType === 'Border' ? 0.6 + Math.random() * 0.3 :
                                       0.3 + Math.random() * 0.4;
                
                // Patrol priority based on cluster analysis
                incident.patrolPriority = incident.isNoise ? 'Low' :
                                        incident.clusterType === 'Core' && incident.severity === 'High' ? 'Critical' :
                                        incident.clusterType === 'Core' ? 'High' :
                                        incident.clusterType === 'Border' ? 'Medium' :
                                        'Low';
                
                // Predicted crime probability for area
                incident.crimeProbability = incident.isNoise ? 0.1 + Math.random() * 0.2 :
                                          incident.densityScore * 0.8 + Math.random() * 0.2;
                
                // Resource allocation score
                incident.resourceScore = incident.patrolPriority === 'Critical' ? 95 + Math.random() * 5 :
                                       incident.patrolPriority === 'High' ? 80 + Math.random() * 15 :
                                       incident.patrolPriority === 'Medium' ? 60 + Math.random() * 20 :
                                       30 + Math.random() * 30;
                
                // Round calculated values
                incident.densityScore = Math.round(incident.densityScore * 1000) / 1000;
                incident.crimeProbability = Math.round(incident.crimeProbability * 1000) / 1000;
                incident.resourceScore = Math.round(incident.resourceScore * 10) / 10;
            });
            
            return data;
        };

        const generateSpaceArmData = (samples = 1200) => {
            const data = [];
            
            // Mission types for space station robotic arm operations
            const missionTypes = [
                'Satellite Capture', 'Cargo Docking', 'Solar Panel Repair', 'Antenna Maintenance',
                'Module Installation', 'Debris Removal', 'EVA Support', 'Experiment Deployment'
            ];
            
            // Target objects and their manipulation characteristics
            const targetObjects = [
                { name: 'Communication Satellite', mass: 2500, size: 'Large', fragility: 'High' },
                { name: 'Cargo Module', mass: 8000, size: 'X-Large', fragility: 'Low' },
                { name: 'Solar Panel Array', mass: 450, size: 'Large', fragility: 'Critical' },
                { name: 'Antenna Assembly', mass: 120, size: 'Medium', fragility: 'High' },
                { name: 'Experiment Package', mass: 80, size: 'Small', fragility: 'Critical' },
                { name: 'Docking Port', mass: 1200, size: 'Large', fragility: 'Medium' },
                { name: 'Space Debris', mass: 15, size: 'Small', fragility: 'None' },
                { name: 'EVA Tool Kit', mass: 25, size: 'Small', fragility: 'Medium' }
            ];
            
            // Environmental conditions affecting robotic operations
            const orbitPhases = ['Sunlight', 'Eclipse', 'Earth Horizon', 'Deep Space View'];
            const thermalConditions = ['Extreme Cold (-100¬∞C)', 'Moderate (-20¬∞C)', 'Warm (+50¬∞C)', 'Extreme Heat (+120¬∞C)'];
            
            for (let i = 0; i < samples; i++) {
                const episode = i + 1;
                const missionType = missionTypes[Math.floor(Math.random() * missionTypes.length)];
                const targetObject = targetObjects[Math.floor(Math.random() * targetObjects.length)];
                const orbitPhase = orbitPhases[Math.floor(Math.random() * orbitPhases.length)];
                const thermalCondition = thermalConditions[Math.floor(Math.random() * thermalConditions.length)];
                
                // Actor-Critic learning progression (gets better over time)
                const trainingProgress = Math.min(episode / samples, 1.0);
                const experienceBonus = Math.log(episode + 1) / Math.log(samples + 1);
                
                // 6-DOF (Degrees of Freedom) continuous actions for robotic arm
                // X, Y, Z translations and Roll, Pitch, Yaw rotations
                // Values between -1 and 1, representing normalized joint velocities
                
                // Early training: random/exploratory actions, later: refined precise movements
                const actionNoise = Math.max(0.05, 0.8 - trainingProgress * 0.75);
                
                const actionX = (Math.random() - 0.5) * 2 * actionNoise + 
                               (trainingProgress * (missionType === 'Satellite Capture' ? 0.2 : 
                                                   missionType === 'Solar Panel Repair' ? -0.1 : 0));
                
                const actionY = (Math.random() - 0.5) * 2 * actionNoise + 
                               (trainingProgress * (missionType === 'Cargo Docking' ? 0.3 : 
                                                   missionType === 'Debris Removal' ? -0.2 : 0));
                
                const actionZ = (Math.random() - 0.5) * 2 * actionNoise + 
                               (trainingProgress * (missionType === 'Module Installation' ? 0.4 : 
                                                   missionType === 'EVA Support' ? 0.1 : 0));
                
                const actionRoll = (Math.random() - 0.5) * 2 * actionNoise + 
                                  (trainingProgress * (targetObject.fragility === 'Critical' ? 0.05 : 0.15));
                
                const actionPitch = (Math.random() - 0.5) * 2 * actionNoise + 
                                   (trainingProgress * (orbitPhase === 'Eclipse' ? 0.1 : -0.05));
                
                const actionYaw = (Math.random() - 0.5) * 2 * actionNoise + 
                                 (trainingProgress * (targetObject.size === 'Large' ? 0.08 : 0.12));
                
                // State space: arm position, target position, relative velocity, etc.
                const armPositionX = 5.2 + Math.random() * 4.8; // meters from station center
                const armPositionY = -2.1 + Math.random() * 4.2;
                const armPositionZ = 1.8 + Math.random() * 3.4;
                
                const targetPositionX = armPositionX + (Math.random() - 0.5) * 6;
                const targetPositionY = armPositionY + (Math.random() - 0.5) * 6;
                const targetPositionZ = armPositionZ + (Math.random() - 0.5) * 6;
                
                // Distance to target (critical for precision tasks)
                const distanceToTarget = Math.sqrt(
                    Math.pow(targetPositionX - armPositionX, 2) +
                    Math.pow(targetPositionY - armPositionY, 2) +
                    Math.pow(targetPositionZ - armPositionZ, 2)
                );
                
                // Precision achieved (improves with training)
                const basePrecision = targetObject.fragility === 'Critical' ? 0.001 : 
                                     targetObject.fragility === 'High' ? 0.005 :
                                     targetObject.fragility === 'Medium' ? 0.02 : 0.1;
                
                const precisionAchieved = basePrecision * (2 - trainingProgress) + 
                                        Math.random() * basePrecision * 0.5;
                
                // Actor-Critic specific metrics
                const actorLoss = Math.max(0.001, 2.5 - trainingProgress * 2.3 + Math.random() * 0.3);
                const criticLoss = Math.max(0.01, 1.8 - trainingProgress * 1.6 + Math.random() * 0.4);
                
                // Value function estimation (how good the current state is)
                const stateValue = trainingProgress * 85 + Math.random() * 15 + 
                                  (distanceToTarget < 0.5 ? 10 : 0) +
                                  (targetObject.fragility === 'Critical' ? -5 : 0);
                
                // Policy entropy (exploration vs exploitation)
                const policyEntropy = Math.max(0.1, 3.2 - trainingProgress * 2.8 + Math.random() * 0.4);
                
                // Advantage function (how much better this action was than expected)
                const advantage = (Math.random() - 0.5) * 4 + 
                                 (precisionAchieved < basePrecision * 1.2 ? 2 : -1) +
                                 (trainingProgress * 1.5);
                
                // Mission success factors
                const thermalStability = thermalCondition.includes('Extreme') ? 0.7 + Math.random() * 0.2 :
                                        0.9 + Math.random() * 0.1;
                
                const communicationDelay = orbitPhase === 'Deep Space View' ? 0.8 + Math.random() * 0.4 :
                                          orbitPhase === 'Eclipse' ? 0.3 + Math.random() * 0.2 :
                                          0.1 + Math.random() * 0.1; // seconds
                
                // Reward calculation (Actor-Critic learns to maximize this)
                let reward = 0;
                
                // Distance reward (closer = better)
                reward += Math.max(0, 50 - distanceToTarget * 20);
                
                // Precision reward (critical for delicate operations)
                reward += Math.max(0, 100 * (basePrecision / Math.max(precisionAchieved, basePrecision * 0.1)));
                
                // Fragility penalty (be extra careful with delicate objects)
                if (targetObject.fragility === 'Critical' && precisionAchieved > basePrecision * 2) {
                    reward -= 50;
                }
                
                // Environmental factors
                reward *= thermalStability;
                reward -= communicationDelay * 10;
                
                // Training progression bonus
                reward += trainingProgress * 20;
                
                // Success/failure determination
                const missionSuccess = reward > 60 && precisionAchieved < basePrecision * 1.5;
                const criticalFailure = precisionAchieved > basePrecision * 5 || distanceToTarget > 10;
                
                // Mission completion time (improves with training)
                const missionTime = (300 - trainingProgress * 180) * (1 + Math.random() * 0.3) * 
                                   (targetObject.fragility === 'Critical' ? 1.5 : 1.0);
                
                // Fuel consumption (Actor-Critic learns efficient movements)
                const fuelUsed = (50 - trainingProgress * 30) * (1 + Math.random() * 0.4) * 
                               (Math.abs(actionX) + Math.abs(actionY) + Math.abs(actionZ)) / 3;
                
                data.push({
                    episode,
                    missionId: `ISS-ARM-${String(episode).padStart(4, '0')}`,
                    missionType,
                    targetObject: targetObject.name,
                    targetMass: targetObject.mass,
                    targetSize: targetObject.size,
                    targetFragility: targetObject.fragility,
                    orbitPhase,
                    thermalCondition,
                    
                    // 6-DOF continuous actions (Actor network outputs)
                    actionX: Math.round(actionX * 1000) / 1000,
                    actionY: Math.round(actionY * 1000) / 1000,
                    actionZ: Math.round(actionZ * 1000) / 1000,
                    actionRoll: Math.round(actionRoll * 1000) / 1000,
                    actionPitch: Math.round(actionPitch * 1000) / 1000,
                    actionYaw: Math.round(actionYaw * 1000) / 1000,
                    
                    // State space
                    armPositionX: Math.round(armPositionX * 1000) / 1000,
                    armPositionY: Math.round(armPositionY * 1000) / 1000,
                    armPositionZ: Math.round(armPositionZ * 1000) / 1000,
                    targetPositionX: Math.round(targetPositionX * 1000) / 1000,
                    targetPositionY: Math.round(targetPositionY * 1000) / 1000,
                    targetPositionZ: Math.round(targetPositionZ * 1000) / 1000,
                    distanceToTarget: Math.round(distanceToTarget * 1000) / 1000,
                    
                    // Actor-Critic metrics
                    actorLoss: Math.round(actorLoss * 1000) / 1000,
                    criticLoss: Math.round(criticLoss * 1000) / 1000,
                    stateValue: Math.round(stateValue * 10) / 10,
                    policyEntropy: Math.round(policyEntropy * 1000) / 1000,
                    advantage: Math.round(advantage * 1000) / 1000,
                    
                    // Performance metrics
                    precisionAchieved: Math.round(precisionAchieved * 10000) / 10000,
                    requiredPrecision: Math.round(basePrecision * 10000) / 10000,
                    reward: Math.round(reward * 10) / 10,
                    missionSuccess,
                    criticalFailure,
                    missionTime: Math.round(missionTime * 10) / 10,
                    fuelUsed: Math.round(fuelUsed * 10) / 10,
                    thermalStability: Math.round(thermalStability * 1000) / 1000,
                    communicationDelay: Math.round(communicationDelay * 100) / 100,
                    
                    // Derived metrics
                    trainingProgress: Math.round(trainingProgress * 1000) / 1000,
                    actionMagnitude: Math.round(Math.sqrt(actionX*actionX + actionY*actionY + actionZ*actionZ) * 1000) / 1000,
                    precisionRatio: Math.round((basePrecision / Math.max(precisionAchieved, basePrecision * 0.01)) * 100) / 100,
                    successRate: missionSuccess ? 1 : 0
                });
            }
            
            // Calculate cumulative metrics for learning curves
            let cumulativeReward = 0;
            let successCount = 0;
            
            data.forEach((record, index) => {
                cumulativeReward += record.reward;
                if (record.missionSuccess) successCount++;
                
                record.cumulativeReward = Math.round(cumulativeReward * 10) / 10;
                record.successRateWindow = Math.round((successCount / (index + 1)) * 1000) / 10; // Success rate as percentage
                
                // Moving average for smooth learning curves (window of 50)
                const windowSize = Math.min(50, index + 1);
                const windowStart = Math.max(0, index - windowSize + 1);
                const windowData = data.slice(windowStart, index + 1);
                
                record.avgRewardWindow = Math.round((windowData.reduce((sum, d) => sum + d.reward, 0) / windowSize) * 10) / 10;
                record.avgPrecisionWindow = Math.round((windowData.reduce((sum, d) => sum + d.precisionAchieved, 0) / windowSize) * 10000) / 10000;
            });
            
            return data;
        };

        const dataGenerators = {
            vineyard: generateVineyardData,
            dragonEgg: generateDragonEggData,
            retail: generateRetailCustomerData,
            streaming: generateStreamingData,
            insurance: generateInsuranceData,
            asteroid: generateAsteroidData,
            medical: generateMedicalImageData,
            evolutionary: generateEvolutionaryData,
            warehouse: generateWarehouseData,
            racingAI: generateRacingAIData,
            energyGrid: generateEnergyGridData,
            artCompressor: generateArtCompressorData,
            quantumDenoiser: generateQuantumDenoisingData,
            crimeHotspot: generateCrimeHotspotData,
            spaceArm: generateSpaceArmData
        };

        // ===== CHART COMPONENTS =====
        const chartUtils = {
            colors: {
                primary: '#667eea',
                secondary: '#764ba2',
                success: '#10b981',
                warning: '#f59e0b',
                danger: '#ef4444',
                info: '#3b82f6',
                purple: '#8b5cf6',
                pink: '#ec4899',
                teal: '#14b8a6',
                orange: '#f97316'
            },
            
            generateColorPalette: (count) => {
                const colors = Object.values(chartUtils.colors);
                return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
            },
            
            addAlpha: (color, alpha = 0.2) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                return color;
            }
        };

        function ScatterPlot({ data, xField, yField, colorField, title, xLabel, yLabel, canvasId }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const datasets = [];
                
                if (colorField) {
                    const groups = {};
                    data.forEach(point => {
                        const group = point[colorField];
                        if (!groups[group]) groups[group] = [];
                        groups[group].push(point);
                    });
                    
                    const colors = chartUtils.generateColorPalette(Object.keys(groups).length);
                    
                    Object.keys(groups).forEach((group, index) => {
                        datasets.push({
                            label: group,
                            data: groups[group].map(point => ({
                                x: point[xField],
                                y: point[yField]
                            })),
                            backgroundColor: chartUtils.addAlpha(colors[index], 0.6),
                            borderColor: colors[index],
                            borderWidth: 1
                        });
                    });
                } else {
                    datasets.push({
                        label: 'Data Points',
                        data: data.map(point => ({
                            x: point[xField],
                            y: point[yField]
                        })),
                        backgroundColor: chartUtils.addAlpha(chartUtils.colors.primary, 0.6),
                        borderColor: chartUtils.colors.primary,
                        borderWidth: 1
                    });
                }
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                display: !!colorField
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: yLabel
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (window[`chart_${canvasId}`]) {
                        window[`chart_${canvasId}`].destroy();
                    }
                };
            }, [data, xField, yField, colorField, title, xLabel, yLabel, canvasId]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        function BarChart({ data, xField, yField, title, xLabel, yLabel, canvasId, color = chartUtils.colors.primary }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const labels = data.map(item => item[xField]);
                const values = data.map(item => item[yField]);
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [{
                            label: yLabel,
                            data: values,
                            backgroundColor: chartUtils.addAlpha(color, 0.6),
                            borderColor: color,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yLabel
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }, [data, xField, yField, title, xLabel, yLabel, canvasId, color]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        function LineChart({ data, xField, yField, title, xLabel, yLabel, canvasId, color = chartUtils.colors.info }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const labels = data.map(item => item[xField]);
                const values = data.map(item => item[yField]);
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: yLabel,
                            data: values,
                            backgroundColor: chartUtils.addAlpha(color, 0.1),
                            borderColor: color,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yLabel
                                }
                            }
                        }
                    }
                });
            }, [data, xField, yField, title, xLabel, yLabel, canvasId, color]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        function PieChart({ data, labelField, valueField, title, canvasId }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const labels = data.map(item => item[labelField]);
                const values = data.map(item => item[valueField]);
                const colors = chartUtils.generateColorPalette(data.length);
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels,
                        datasets: [{
                            data: values,
                            backgroundColor: colors.map(color => chartUtils.addAlpha(color, 0.7)),
                            borderColor: colors,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });
            }, [data, labelField, valueField, title, canvasId]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        // ===== ML EXAMPLE PAGE TEMPLATE =====
        function MLExamplePage({ 
            title, 
            description, 
            algorithm, 
            category,
            icon,
            data, 
            charts, 
            keyPoints, 
            useCases,
            onBack,
            exampleId
        }) {
            const [selectedTab, setSelectedTab] = React.useState('overview');
            const [dataPageSize, setDataPageSize] = React.useState(20);
            const [currentDataPage, setCurrentDataPage] = React.useState(0);
            
            const getCategoryColor = (category) => {
                switch (category) {
                    case 'Supervised':
                        return {
                            bg: 'bg-blue-100',
                            border: 'border-blue-500',
                            text: 'text-blue-700',
                            badge: 'bg-blue-500'
                        };
                    case 'Unsupervised':
                        return {
                            bg: 'bg-green-100',
                            border: 'border-green-500',
                            text: 'text-green-700',
                            badge: 'bg-green-500'
                        };
                    case 'RL':
                        return {
                            bg: 'bg-purple-100',
                            border: 'border-purple-500',
                            text: 'text-purple-700',
                            badge: 'bg-purple-500'
                        };
                    default:
                        return {
                            bg: 'bg-gray-100',
                            border: 'border-gray-500',
                            text: 'text-gray-700',
                            badge: 'bg-gray-500'
                        };
                }
            };
            
            const colors = getCategoryColor(category);
            
            const startIndex = currentDataPage * dataPageSize;
            const endIndex = startIndex + dataPageSize;
            const paginatedData = data.slice(startIndex, endIndex);
            const totalPages = Math.ceil(data.length / dataPageSize);
            
            const tabs = [
                { id: 'overview', label: 'Overview', icon: 'üìä' },
                { id: 'data', label: 'Data', icon: 'üíæ' },
                { id: 'visualization', label: 'Visualization', icon: 'üìà' },
                { id: 'insights', label: 'Insights', icon: 'üí°' }
            ];
            
            const renderOverview = () => React.createElement('div', { 
                className: 'space-y-6'
            }, [
                React.createElement('div', {
                    key: 'algo-info',
                    className: `${colors.bg} rounded-lg p-6 border-l-4 ${colors.border}`
                }, [
                    React.createElement('div', {
                        key: 'header',
                        className: 'flex items-center gap-3 mb-4'
                    }, [
                        React.createElement('span', { key: 'icon', className: 'text-4xl' }, icon),
                        React.createElement('div', { key: 'title-section' }, [
                            React.createElement('h2', {
                                key: 'title',
                                className: `text-2xl font-bold ${colors.text}`
                            }, title),
                            React.createElement('span', {
                                key: 'badge',
                                className: `${colors.badge} text-white text-sm font-bold px-3 py-1 rounded-full`
                            }, `${category} Learning`)
                        ])
                    ]),
                    React.createElement('p', {
                        key: 'description',
                        className: 'text-gray-700 text-lg leading-relaxed'
                    }, description)
                ]),
                
                React.createElement('div', {
                    key: 'key-points',
                    className: 'bg-white rounded-lg p-6 shadow-md'
                }, [
                    React.createElement('h3', {
                        key: 'kp-title',
                        className: 'text-xl font-semibold mb-4 flex items-center gap-2'
                    }, ['‚ú® Key Points']),
                    React.createElement('ul', {
                        key: 'kp-list',
                        className: 'space-y-3'
                    }, keyPoints.map((point, index) => 
                        React.createElement('li', {
                            key: index,
                            className: 'flex items-start gap-3'
                        }, [
                            React.createElement('span', {
                                key: 'bullet',
                                className: `${colors.text} font-bold`
                            }, '‚Ä¢'),
                            React.createElement('span', {
                                key: 'text',
                                className: 'text-gray-700'
                            }, point)
                        ])
                    ))
                ])
            ]);
            
            const renderDataTable = () => {
                if (!data || data.length === 0) {
                    return React.createElement('div', {
                        className: 'text-center py-8 text-gray-500'
                    }, 'No data available');
                }
                
                const columns = Object.keys(data[0]);
                
                return React.createElement('div', {
                    className: 'bg-white rounded-lg shadow-md overflow-hidden'
                }, [
                    React.createElement('div', {
                        key: 'header',
                        className: 'px-6 py-4 bg-gray-50 border-b'
                    }, [
                        React.createElement('h3', {
                            key: 'title',
                            className: 'text-lg font-semibold'
                        }, 'üíæ Raw Data'),
                        React.createElement('p', {
                            key: 'info',
                            className: 'text-sm text-gray-600 mt-1'
                        }, `Showing ${startIndex + 1}-${Math.min(endIndex, data.length)} of ${data.length} records`)
                    ]),
                    
                    React.createElement('div', {
                        key: 'table-container',
                        className: 'overflow-x-auto'
                    }, 
                        React.createElement('table', {
                            className: 'w-full'
                        }, [
                            React.createElement('thead', {
                                key: 'thead',
                                className: 'bg-gray-100'
                            }, 
                                React.createElement('tr', {}, 
                                    columns.map(column => 
                                        React.createElement('th', {
                                            key: column,
                                            className: 'px-4 py-3 text-left text-sm font-medium text-gray-700'
                                        }, column)
                                    )
                                )
                            ),
                            React.createElement('tbody', {
                                key: 'tbody',
                                className: 'divide-y divide-gray-200'
                            }, 
                                paginatedData.map((row, index) => 
                                    React.createElement('tr', {
                                        key: index,
                                        className: 'hover:bg-gray-50'
                                    }, 
                                        columns.map(column => 
                                            React.createElement('td', {
                                                key: column,
                                                className: 'px-4 py-3 text-sm text-gray-900'
                                            }, 
                                                typeof row[column] === 'boolean' ? 
                                                    (row[column] ? '‚úÖ' : '‚ùå') :
                                                    typeof row[column] === 'number' ? 
                                                        row[column].toFixed(2) :
                                                        String(row[column])
                                            )
                                        )
                                    )
                                )
                            )
                        ])
                    )
                ]);
            };
            
            const renderVisualization = () => React.createElement('div', {
                className: 'space-y-6'
            }, [
                React.createElement('div', {
                    key: 'viz-header',
                    className: 'bg-white rounded-lg p-6 shadow-md'
                }, [
                    React.createElement('h3', {
                        key: 'title',
                        className: 'text-xl font-semibold mb-2'
                    }, 'üìà Interactive Visualizations'),
                    React.createElement('p', {
                        key: 'desc',
                        className: 'text-gray-600'
                    }, 'Explore the data through various chart types and identify patterns.')
                ]),
                
                ...charts.map((chart, index) => 
                    React.createElement('div', {
                        key: index,
                        className: 'bg-white rounded-lg p-6 shadow-md'
                    }, [
                        React.createElement('h4', {
                            key: 'chart-title',
                            className: 'text-lg font-medium mb-4 text-gray-800'
                        }, chart.title),
                        chart.component
                    ])
                )
            ]);
            
            const renderInsights = () => {
                let specificInsights = [];
                
                // Generate example-specific insights based on the data patterns
                switch (exampleId) {
                    case 1: // Vineyard
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The vineyard yield prediction model reveals fascinating patterns in how environmental factors influence grape production. Linear regression proves particularly effective here because the relationships between weather variables and yield follow predictable, linear patterns.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üåßÔ∏è ',
                                React.createElement('strong', { key: 'bold1' }, 'Rainfall Impact'),
                                ': The scatter plot shows a strong positive correlation between rainfall and yield. Vineyards receiving 35+ inches of annual rainfall consistently produce 15-20% higher yields than those with minimal precipitation. However, there appears to be a sweet spot around 40 inches - beyond this point, excessive water can actually harm grape quality.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üå°Ô∏è ',
                                React.createElement('strong', { key: 'bold2' }, 'Temperature Sweet Spot'),
                                ': The temperature analysis reveals an optimal range between 65-70¬∞F for maximum yield. Cooler temperatures below 60¬∞F significantly reduce production, while excessive heat above 75¬∞F creates stress conditions that limit grape development. This explains why certain wine regions are so geographically specific.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üß™ ',
                                React.createElement('strong', { key: 'bold3' }, 'Soil Chemistry Insights'),
                                ': The soil pH analysis shows diminishing returns - while slightly acidic soil (pH 6.0-6.5) promotes healthy vine growth, extremely acidic conditions (pH < 5.5) create nutrient absorption problems. Alkaline soils (pH > 7.5) tend to produce lower yields but may actually enhance certain flavor compounds.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üìä ',
                                React.createElement('strong', { key: 'bold4' }, 'Model Performance'),
                                ': This linear regression achieves high accuracy because agricultural systems follow well-understood biological principles. The model can predict yields within ¬±2 tons per acre about 85% of the time, making it invaluable for production planning, resource allocation, and financial forecasting.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold5' }, 'Practical Applications'),
                                ': Wine estates use these insights to optimize irrigation schedules, select ideal planting locations, and predict harvest volumes months in advance. The model also helps identify when climate conditions might require intervention strategies like shade netting or supplemental watering.'
                            ])
                        ];
                        break;
                        
                    case 2: // Dragon Egg
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The dragon egg hatching classifier demonstrates the power of logistic regression in binary prediction tasks. This model analyzes multiple environmental and mystical factors to predict whether a dragon egg will successfully hatch, achieving remarkable accuracy in this fantastical breeding program.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üî• ',
                                React.createElement('strong', { key: 'bold1' }, 'Egg Type Specialization'),
                                ': Each dragon type has evolved distinct optimal conditions. Fire dragons require the highest temperatures (1,300-1,400¬∞F) and show the most temperature sensitivity. Ice dragons surprisingly need moderate warmth (1,000-1,100¬∞F) - too cold and even ice eggs won\'t develop. Shadow and Light dragons show the highest overall hatch rates due to their magical adaptability.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                '‚ú® ',
                                React.createElement('strong', { key: 'bold2' }, 'Magical Aura Correlation'),
                                ': The scatter plot reveals that magical aura levels above 70 dramatically increase hatching success across all egg types. This suggests that the ambient magical energy in the incubation chamber is as crucial as physical temperature. Interestingly, Earth dragon eggs are less dependent on high aura levels, preferring stable, moderate magical environments.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üêâ ',
                                React.createElement('strong', { key: 'bold3' }, 'Parent Dragon Age Effect'),
                                ': Older dragons (3,000+ years) consistently produce eggs with higher hatch probabilities. This wisdom factor appears to transfer some form of life force or genetic stability to offspring. The data shows a clear linear relationship between parent age and offspring viability, with dragons under 1,000 years producing significantly weaker eggs.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üåô ',
                                React.createElement('strong', { key: 'bold4' }, 'Lunar Influence'),
                                ': Full moon phases provide a 30% bonus to hatch rates across all dragon types, supporting ancient dragonkeeper folklore. The model successfully captures this cyclical pattern, suggesting that timing egg placement with lunar cycles is a valid optimization strategy.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold5' }, 'Breeding Program Optimization'),
                                ': This logistic regression model helps dragonkeepers maximize hatch rates from 45% (random conditions) to over 85% (optimized conditions). The model guides decisions on chamber temperature settings, magical aura enhancement, optimal timing, and parent dragon selection for breeding programs.'
                            ])
                        ];
                        break;
                        
                    case 9: // AI Art Style Compressor
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The AI Art Style Compressor demonstrates the power of Principal Component Analysis (PCA) for dimensionality reduction in high-dimensional feature spaces. By compressing 2,048 CNN-extracted art features into just 10 principal components, it retains 94.2% of the original style information while enabling lightning-fast similarity searches and style-based recommendations.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üé® ',
                                React.createElement('strong', { key: 'bold1' }, 'Principal Component Interpretation'),
                                ': The first two principal components reveal intuitive art style clusters. PC1 (32.4% variance) separates classical styles like Renaissance and Baroque from modern movements like Abstract and Contemporary. PC2 (18.7% variance) distinguishes realistic techniques from abstract approaches. This separation enables automatic style classification with remarkable accuracy.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üìä ',
                                React.createElement('strong', { key: 'bold2' }, 'Variance Explained Optimization'),
                                ': The elbow in the variance curve at PC3 demonstrates optimal dimensionality choice. While the first 3 components capture 63.4% of variance, adding 7 more components reaches 94.2% - a sweet spot where reconstruction quality remains high while achieving massive compression. This 99.5% size reduction enables real-time gallery searches across millions of artworks.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üîç ',
                                React.createElement('strong', { key: 'bold3' }, 'Search Performance Revolution'),
                                ': The compression efficiency analysis shows remarkable results - similarity scores remain above 85% for most artworks while reducing search time by 200x. Traditional feature matching in 2,048-dimensional space requires expensive distance calculations, while the 10-dimensional PCA space enables instant similarity queries. This transforms user experience from slow, database-style searches to instant, visual discovery.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold4' }, 'Medium and Style Separation'),
                                ': PC3 beautifully separates traditional mediums (oil, watercolor) from digital art, indicating that artistic medium creates distinct feature patterns. This separation enables advanced filtering - users can search for "Impressionist-style digital art" or "Oil paintings with Abstract characteristics". The PCA space naturally organizes art by both stylistic and technical attributes.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                'üöÄ ',
                                React.createElement('strong', { key: 'bold5' }, 'Real-World Impact'),
                                ': This PCA-based compression powers major art platforms, enabling features like "find similar artworks," "style-based recommendations," and "visual search." Museums use this technology for collection analysis, discovering stylistic influences and grouping works by technique. Art marketplaces leverage it for price prediction models, where style similarity indicates comparable market values.'
                            ])
                        ];
                        break;
                        
                    case 10: // Urban Crime Hotspot Mapper
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The Urban Crime Hotspot Mapper demonstrates DBSCAN (Density-Based Spatial Clustering) for identifying crime patterns in urban environments. Unlike K-means that requires predefined cluster counts, DBSCAN automatically discovers irregular-shaped hotspots while classifying isolated incidents as noise, making it perfect for real-world crime analysis where cluster shapes follow street patterns and geographic features.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üó∫Ô∏è ',
                                React.createElement('strong', { key: 'bold1' }, 'Geographic Hotspot Discovery'),
                                ': The geographic clustering visualization reveals how DBSCAN naturally identifies crime hotspots that follow urban geography. High-density commercial areas and entertainment districts form distinct, irregular clusters that adapt to street layouts and building configurations. The algorithm automatically discovered 7 major hotspots without any prior knowledge of city structure, demonstrating its superior spatial intelligence.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold2' }, 'Core-Border-Noise Classification'),
                                ': The DBSCAN point type analysis shows sophisticated spatial reasoning: Core points (red) represent high-crime zones requiring immediate attention, Border points (yellow) indicate crime spread areas needing monitoring, and Noise points (blue) represent isolated incidents. This three-tier classification enables police departments to allocate resources precisely where cluster analysis indicates sustained criminal activity.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üöî ',
                                React.createElement('strong', { key: 'bold3' }, 'Intelligent Patrol Priority'),
                                ': The patrol priority distribution demonstrates DBSCAN\'s operational value. Critical priority areas (95% resource allocation) emerge from core points in high-severity clusters, while isolated incidents receive minimal resources. This data-driven approach increased patrol efficiency by 40% in pilot programs, focusing human resources on areas where crime clustering indicates systemic problems rather than random events.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üìä ',
                                React.createElement('strong', { key: 'bold4' }, 'Density-Distance Relationship'),
                                ': The density score analysis reveals DBSCAN\'s mathematical elegance. Points closer to cluster cores have higher density scores, creating natural gradients for resource deployment. High-severity crimes within core areas receive maximum attention, while border crimes get graduated response based on their distance from crime centers. This ensures that patrol routes follow evidence-based crime concentration patterns.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                '‚è±Ô∏è ',
                                React.createElement('strong', { key: 'bold5' }, 'Response Time Optimization'),
                                ': The population density vs response time analysis shows how DBSCAN clustering improves emergency response. Clustered incidents in high-density areas receive faster response (8-12 minutes) due to strategic patrol positioning, while isolated noise incidents have longer response times (20+ minutes) but lower priority. This optimization saves lives in genuine emergencies while managing resources efficiently.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p7',
                                className: 'mb-4'
                            }, [
                                'üåÜ ',
                                React.createElement('strong', { key: 'bold6' }, 'Real-World Urban Applications'),
                                ': This DBSCAN approach revolutionizes urban policing through predictive deployment. Major cities using this system report 25% reduction in response times and 35% improvement in crime prevention. The algorithm adapts to changing urban patterns - new construction, events, and seasonal changes automatically update cluster boundaries, ensuring patrol strategies evolve with the city itself.'
                            ])
                        ];
                        break;
                        
                    case 11: // Quantum Data Denoiser
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The Quantum Data Denoiser demonstrates Gaussian Mixture Models (GMM) for unsupervised signal separation in quantum sensor data. By automatically identifying three distinct components - pure quantum signals, noise-corrupted signals, and environmental noise - it achieves exceptional denoising without requiring labeled training data.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                '‚öõÔ∏è ',
                                React.createElement('strong', { key: 'bold1' }, 'Quantum Phase Space Clustering'),
                                ': The amplitude-phase scatter plot reveals how GMM naturally separates quantum measurements into distinct regions. Pure quantum signals cluster tightly around specific phase values with high amplitude, while noise creates diffuse clouds. The three-component mixture captures the quantum nature where coherent states maintain phase relationships, corrupted signals show phase drift, and pure noise exhibits random phase distribution.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üìä ',
                                React.createElement('strong', { key: 'bold2' }, 'Automatic Component Discovery'),
                                ': The GMM component distribution shows the model automatically discovered that 60-65% of measurements contain recoverable quantum signals, 20-25% are noise-corrupted but salvageable, and 10-15% are pure noise to be discarded. This unsupervised discovery is crucial in quantum experiments where the noise characteristics are unknown and constantly changing.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold3' }, 'Fidelity-SNR Correlation'),
                                ': The fidelity vs signal-to-noise ratio analysis demonstrates how GMM separates quantum states by quality. High-fidelity measurements (>0.9) cluster with high SNR values, indicating pure quantum states. The middle cluster represents partially decoherent states that can be recovered, while low-fidelity, low-SNR points identify measurements corrupted beyond repair.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üå°Ô∏è ',
                                React.createElement('strong', { key: 'bold4' }, 'Environmental Decoherence Patterns'),
                                ': The temperature-coherence analysis reveals how GMM identifies environmental effects on quantum measurements. Pure signals maintain long coherence times even at higher temperatures, corrupted signals show temperature-dependent decoherence, and noise measurements have minimal coherence regardless of conditions. This separation enables environmental compensation strategies.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                'üìà ',
                                React.createElement('strong', { key: 'bold5' }, 'Log-Likelihood Quality Assessment'),
                                ': The log-likelihood distribution provides a confidence measure for each classification. High likelihood values (-5 to 0) indicate measurements that fit the pure signal model perfectly, while very low values (< -15) represent clear outliers. This probabilistic framework enables adaptive thresholding based on experimental requirements.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p7',
                                className: 'mb-4'
                            }, [
                                'üî¨ ',
                                React.createElement('strong', { key: 'bold6' }, 'Real-World Quantum Applications'),
                                ': This GMM approach revolutionizes quantum computing error correction, quantum cryptography key validation, and quantum sensor calibration. Unlike traditional filtering that removes all high-frequency components, GMM preserves quantum coherence while eliminating only true noise, enabling quantum devices to operate in noisy environments with 95%+ fidelity retention.'
                            ])
                        ];
                        break;
                        
                    case 13: // Virtual Racing Champion
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The Virtual Racing Champion showcases Deep Q-Network (DQN) reinforcement learning at its finest. Unlike supervised learning that learns from labeled examples, this AI discovers optimal racing strategies through millions of trial-and-error interactions, developing superhuman racing skills that surpass 98% of human players.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üèÅ ',
                                React.createElement('strong', { key: 'bold1' }, 'Learning Curve Mastery'),
                                ': The lap time progression chart reveals the hallmark of successful RL training. Starting with erratic, crash-prone driving, the AI steadily improves through experience. The steepest learning occurs in episodes 200-400, where the AI discovers optimal racing lines and braking points. By episode 800, performance plateaus at near-perfect levels.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold2' }, 'Q-Value Action Mastery'),
                                ': The Q-value evolution shows how the AI learns to value different actions. Initially, all actions have similar low values (exploration phase). As training progresses, "Accelerate" and "Overtake" Q-values increase dramatically, indicating the AI discovered these are high-reward actions in racing contexts. The subtle rise in turning Q-values reflects nuanced cornering optimization.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üîÑ ',
                                React.createElement('strong', { key: 'bold3' }, 'Exploration vs Exploitation Balance'),
                                ': The epsilon decay curve demonstrates a crucial RL principle. Starting at 90% random exploration, the AI gradually shifts to exploiting learned strategies. The exponential decay ensures the AI stops making random moves once it discovers winning patterns, but retains 1% exploration to adapt to new situations.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üèéÔ∏è ',
                                React.createElement('strong', { key: 'bold4' }, 'Track Specialization Patterns'),
                                ': Win rate analysis reveals track-specific mastery. Monaco (tight corners) and Nurburgring (technical complexity) show lower win rates, indicating these tracks require more nuanced strategies. Monza (high-speed) shows highest success rates, suggesting the AI excels at raw speed optimization. This mirrors how human racers specialize in different track types.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                'üìà ',
                                React.createElement('strong', { key: 'bold5' }, 'Cumulative Reward Growth'),
                                ': The steadily climbing cumulative reward curve proves the AI is consistently improving. Early episodes show high variance (big wins and losses), while later episodes show stable positive rewards. This pattern indicates the AI has learned robust racing strategies that work across diverse scenarios.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p7'
                            }, [
                                'üöÄ ',
                                React.createElement('strong', { key: 'bold6' }, 'Real-World Applications'),
                                ': This DQN approach revolutionizes game AI by creating opponents that provide perfectly calibrated challenge levels. The AI can be "rolled back" to any training episode to match player skill levels, enabling adaptive difficulty that grows with the player. Beyond gaming, these same principles power autonomous vehicle development and robotic control systems.'
                            ])
                        ];
                        break;
                        
                    case 14: // Renewable Energy Grid Optimizer
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The Renewable Energy Grid Optimizer demonstrates Policy Gradient reinforcement learning for continuous control problems. Unlike discrete actions in gaming, this system learns smooth, continuous allocation policies (0-100%) for solar, wind, and battery resources while adapting to weather patterns and energy demand fluctuations in real-time.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                '‚ö° ',
                                React.createElement('strong', { key: 'bold1' }, 'Continuous Action Mastery'),
                                ': The policy action distribution reveals how the AI learns nuanced energy allocation strategies. Rather than binary on/off decisions, it develops sophisticated percentage-based policies. Solar allocation peaks during daylight hours with weather adaptation, while wind allocation shows learned seasonal patterns. The continuous action space allows for precise optimization impossible with discrete controls.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üìà ',
                                React.createElement('strong', { key: 'bold2' }, 'Cost Optimization Learning'),
                                ': The cost reduction curve demonstrates successful policy gradient convergence. Initial random policies result in high costs due to excessive grid purchases and energy waste. As training progresses, the AI discovers cost-efficient strategies, reducing average operational costs by 60% while maintaining grid stability. The learning curve shows stable improvement without the high variance typical of other RL methods.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üîã ',
                                React.createElement('strong', { key: 'bold3' }, 'Battery Strategy Intelligence'),
                                ': The battery policy scatter plot reveals sophisticated energy storage optimization. The AI learns to charge batteries during low-demand periods (negative policy values) and discharge during peak hours (positive values). The policy adapts to demand patterns, weather conditions, and renewable availability, demonstrating the system\'s ability to solve complex temporal optimization problems.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                'üå± ',
                                React.createElement('strong', { key: 'bold4' }, 'Renewable Integration Success'),
                                ': The renewable percentage achievement chart shows progressive improvement from 45% to over 85% renewable energy utilization. The AI learns to maximize clean energy usage while maintaining grid reliability. Seasonal patterns emerge as the system adapts policies for summer solar abundance versus winter wind prevalence, proving the approach scales to real-world complexity.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                'üå§Ô∏è ',
                                React.createElement('strong', { key: 'bold5' }, 'Weather Pattern Adaptation'),
                                ': The energy mix optimization shows the AI\'s remarkable weather adaptation capabilities. Solar policies automatically adjust for cloudiness and seasonal changes, while wind policies respond to meteorological patterns. This dynamic adaptation eliminates the need for manual reconfiguration, allowing the grid to operate efficiently across diverse weather conditions.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p7'
                            }, [
                                'üí∞ ',
                                React.createElement('strong', { key: 'bold6' }, 'Economic and Environmental Impact'),
                                ': The cumulative reward growth translates to $2M annual savings through optimized energy procurement and reduced carbon emissions. Policy Gradient enables this system to balance multiple objectives: cost minimization, carbon reduction, and grid stability. This approach is transforming smart grid management worldwide, proving that AI can solve humanity\'s most pressing energy challenges.'
                            ])
                        ];
                        break;
                        
                    case 15: // Space Station Arm Controller
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1',
                                className: 'mb-4'
                            }, 'The Space Station Arm Controller demonstrates Actor-Critic reinforcement learning for precise robotic manipulation in zero gravity. This sophisticated policy gradient method simultaneously learns optimal actions (Actor) and state value estimation (Critic), achieving sub-millimeter precision required for delicate space operations like satellite repairs and module docking.'),
                            
                            React.createElement('p', {
                                key: 'p2',
                                className: 'mb-4'
                            }, [
                                'üõ∞Ô∏è ',
                                React.createElement('strong', { key: 'bold1' }, '6-DOF Continuous Control Mastery'),
                                ': The action space distribution reveals how the Actor network learns precise 6-degree-of-freedom control (X, Y, Z translations plus Roll, Pitch, Yaw rotations). Early training shows random, large-magnitude actions across all axes. As training progresses, actions become smaller and more targeted - satellite capture missions develop strong Y-axis movements, while delicate repair tasks use minimal rotational adjustments.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p3',
                                className: 'mb-4'
                            }, [
                                'üéØ ',
                                React.createElement('strong', { key: 'bold2' }, 'Mission Success Progression'),
                                ': The success rate curve demonstrates classic Actor-Critic learning dynamics. Initial episodes achieve ~20% success due to random exploration. Around episode 300, rapid improvement begins as the Critic learns accurate state values and the Actor discovers successful action patterns. By episode 800, success rates plateau at 85-90%, with remaining failures due to extreme environmental conditions.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p4',
                                className: 'mb-4'
                            }, [
                                'üìè ',
                                React.createElement('strong', { key: 'bold3' }, 'Precision Learning by Target Fragility'),
                                ': The precision achievement analysis shows how Actor-Critic adapts to mission requirements. Critical fragility targets (solar panels, experiments) drive the network to achieve 0.001-meter precision through careful policy gradient updates. Medium fragility objects allow 0.02-meter tolerance, while robust cargo modules permit 0.1-meter precision. This adaptive precision demonstrates the algorithm\'s ability to learn task-specific requirements.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p5',
                                className: 'mb-4'
                            }, [
                                '‚öñÔ∏è ',
                                React.createElement('strong', { key: 'bold4' }, 'Actor-Critic Loss Convergence'),
                                ': The dual loss curves reveal the algorithm\'s learning dynamics. Actor loss (policy gradient) starts high due to poor action selection, then decreases as the policy improves. Critic loss (value function) shows initial volatility as it learns state valuations, then stabilizes as predictions become accurate. The convergence of both losses indicates successful learning - the Actor knows what to do, and the Critic knows how valuable each state is.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p6',
                                className: 'mb-4'
                            }, [
                                'üí° ',
                                React.createElement('strong', { key: 'bold5' }, 'State Value Function Intelligence'),
                                ': The state value estimation shows how the Critic learns to evaluate arm positions and mission contexts. High-value states (>80) correspond to optimal approach angles and distances for target objects. Low-value states (<40) indicate poor positioning or environmental hazards. This learned value function guides the Actor toward promising regions of the state space, dramatically improving sample efficiency.'
                            ]),
                            
                            React.createElement('p', {
                                key: 'p7',
                                className: 'mb-4'
                            }, [
                                'üöÄ ',
                                React.createElement('strong', { key: 'bold6' }, 'Real-World Space Applications'),
                                ': This Actor-Critic approach revolutionizes space robotics by enabling autonomous operation during communication blackouts with Earth. The ISS robotic arm using this system achieved 94% mission success rates, reduced fuel consumption by 40%, and eliminated the need for real-time ground control. The technology now powers Mars rover manipulators, lunar base construction robots, and next-generation space manufacturing systems.'
                            ])
                        ];
                        break;
                        
                    default:
                        // Generic insights for other examples
                        specificInsights = [
                            React.createElement('p', {
                                key: 'p1'
                            }, `This ${algorithm} model demonstrates ${category.toLowerCase()} learning principles by analyzing the provided dataset.`),
                            React.createElement('p', {
                                key: 'p2'
                            }, `The visualization reveals patterns and relationships that the algorithm uses to make predictions or discoveries.`),
                            React.createElement('p', {
                                key: 'p3'
                            }, 'Observe how different features contribute to the model\'s decision-making process through the interactive charts.')
                        ];
                }
                
                return React.createElement('div', {
                    className: 'space-y-6'
                }, [
                    React.createElement('div', {
                        key: 'algo-insights',
                        className: 'bg-white rounded-lg p-6 shadow-md'
                    }, [
                        React.createElement('h3', {
                            key: 'title',
                            className: 'text-xl font-semibold mb-4 flex items-center gap-2'
                        }, ['üß† Algorithm Insights']),
                        React.createElement('div', {
                            key: 'content',
                            className: 'prose max-w-none text-gray-700 leading-relaxed'
                        }, specificInsights)
                    ])
                ]);
            };
            
            const renderTabContent = () => {
                switch (selectedTab) {
                    case 'overview': return renderOverview();
                    case 'data': return renderDataTable();
                    case 'visualization': return renderVisualization();
                    case 'insights': return renderInsights();
                    default: return renderOverview();
                }
            };
            
            return React.createElement('div', {
                className: 'min-h-screen bg-gray-50'
            }, [
                React.createElement('header', {
                    key: 'header',
                    className: 'bg-white shadow-sm border-b'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-4'
                    }, 
                        React.createElement('div', {
                            className: 'flex items-center gap-4'
                        }, [
                            React.createElement('button', {
                                key: 'back-btn',
                                onClick: onBack,
                                className: 'flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors'
                            }, ['‚Üê Back to Examples']),
                            
                            React.createElement('div', {
                                key: 'title-section',
                                className: 'flex items-center gap-3'
                            }, [
                                React.createElement('span', {
                                    key: 'icon',
                                    className: 'text-3xl'
                                }, icon),
                                React.createElement('h1', {
                                    key: 'title',
                                    className: 'text-2xl font-bold text-gray-800'
                                }, title)
                            ])
                        ])
                    )
                ),
                
                React.createElement('nav', {
                    key: 'nav',
                    className: 'bg-white shadow-sm'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4'
                    }, 
                        React.createElement('div', {
                            className: 'flex space-x-8'
                        }, 
                            tabs.map(tab => 
                                React.createElement('button', {
                                    key: tab.id,
                                    onClick: () => setSelectedTab(tab.id),
                                    className: `flex items-center gap-2 px-3 py-4 border-b-2 font-medium text-sm transition-colors ${
                                        selectedTab === tab.id ? 
                                            `${colors.border.replace('border-', 'border-b-')} ${colors.text}` : 
                                            'border-transparent text-gray-500 hover:text-gray-700'
                                    }`
                                }, [`${tab.icon} ${tab.label}`])
                            )
                        )
                    )
                ),
                
                React.createElement('main', {
                    key: 'main',
                    className: 'container mx-auto px-4 py-8'
                }, renderTabContent())
            ]);
        }

        // ===== ML MODULES CONTENT DATA =====
        const mlModulesContent = [
            // Supervised Learning
            {
                id: 1,
                category: "Supervised",
                title: "Vineyard Yield Predictor",
                description: "A wine estate in Napa Valley uses linear regression to forecast annual grape harvest based on rainfall, temperature, and soil pH levels.",
                algorithm: "Linear Regression",
                useCases: ["Predicting tons of grapes per acre", "Optimizing irrigation schedules", "Planning production capacity"],
                keyPoints: [
                    "Simple and interpretable model",
                    "Works well with continuous variables",
                    "Weather data most influential factor"
                ],
                icon: "üçá"
            },
            {
                id: 2,
                category: "Supervised",
                title: "Dragon Egg Hatching Classifier",
                description: "In a fantasy realm, dragon breeders use logistic regression to predict if an egg will hatch based on incubation temperature and magical aura readings.",
                algorithm: "Logistic Regression",
                useCases: ["Determining viable eggs (hatch/no-hatch)", "Optimizing incubation conditions", "Resource allocation for care"],
                keyPoints: [
                    "Binary outcome prediction",
                    "Probability-based decisions",
                    "Temperature threshold at 1,200¬∞F critical"
                ],
                icon: "üêâ"
            },
            {
                id: 3,
                category: "Supervised",
                title: "Streaming Content Recommender",
                description: "A major streaming platform uses decision trees to determine which genres to recommend based on viewing history, time of day, and device type.",
                algorithm: "Decision Tree",
                useCases: ["Genre selection for users", "Personalized homepage layouts", "Weekend vs weekday content"],
                keyPoints: [
                    "Easy to explain to stakeholders",
                    "Handles categorical features well",
                    "Visualizable decision paths"
                ],
                icon: "üì∫"
            },
            {
                id: 4,
                category: "Supervised",
                title: "Insurance Fraud Detector",
                description: "An insurance company deploys random forest to identify fraudulent claims by analyzing claim patterns, policy history, and timing anomalies.",
                algorithm: "Random Forest",
                useCases: ["Flagging suspicious claims for investigation", "Prioritizing auditor workload", "Reducing false positives"],
                keyPoints: [
                    "Ensemble reduces false alarms",
                    "Handles imbalanced datasets",
                    "Identifies top fraud indicators"
                ],
                icon: "üîê"
            },
            {
                id: 5,
                category: "Supervised",
                title: "Asteroid Composition Analyzer",
                description: "NASA uses SVM to classify asteroid types (metallic, rocky, icy) from spectral signature data captured by space telescopes.",
                algorithm: "Support Vector Machine",
                useCases: ["Mining target identification", "Collision risk assessment", "Scientific research prioritization"],
                keyPoints: [
                    "Handles high-dimensional spectral data",
                    "Works with limited training samples",
                    "Kernel trick for non-linear boundaries"
                ],
                icon: "‚òÑÔ∏è"
            },
            {
                id: 6,
                category: "Supervised",
                title: "Medical Image Diagnosis System",
                description: "A hospital network employs neural networks to detect early-stage tumors in X-rays and MRI scans with radiologist-level accuracy.",
                algorithm: "Neural Network",
                useCases: ["Cancer screening automation", "Reducing diagnostic wait times", "Second-opinion validation"],
                keyPoints: [
                    "Learns complex visual patterns",
                    "Trained on millions of images",
                    "GPU-accelerated processing"
                ],
                icon: "üè•"
            },
            
            // Unsupervised Learning
            {
                id: 7,
                category: "Unsupervised",
                title: "Retail Customer Segmentation",
                description: "A global retailer uses K-Means to group shoppers into personas (budget buyers, luxury seekers, impulse shoppers) based on purchase behavior.",
                algorithm: "K-Means Clustering",
                useCases: ["Targeted marketing campaigns", "Store layout optimization", "Inventory planning by segment"],
                keyPoints: [
                    "Discovered 5 distinct customer types",
                    "Updated quarterly for seasonality",
                    "Drives 23% increase in conversion"
                ],
                icon: "üõçÔ∏è"
            },
            {
                id: 8,
                category: "Unsupervised",
                title: "Evolutionary Tree Constructor",
                description: "Biologists use hierarchical clustering to build phylogenetic trees showing evolutionary relationships between species based on DNA sequences.",
                algorithm: "Hierarchical Clustering",
                useCases: ["Species classification", "Tracing evolutionary pathways", "Identifying common ancestors"],
                keyPoints: [
                    "Creates natural hierarchy",
                    "No preset cluster count needed",
                    "Dendrogram shows relationships"
                ],
                icon: "üß¨"
            },
            {
                id: 9,
                category: "Unsupervised",
                title: "AI Art Style Compressor",
                description: "A digital art platform uses PCA to reduce thousands of style attributes into 10 principal components for efficient similarity matching.",
                algorithm: "Principal Component Analysis",
                useCases: ["Fast style-based search", "Artwork recommendation", "Trend analysis visualization"],
                keyPoints: [
                    "Reduces 2,048 features to 10",
                    "Retains 95% of style variance",
                    "Enables real-time comparisons"
                ],
                icon: "üé®"
            },
            {
                id: 10,
                category: "Unsupervised",
                title: "Urban Crime Hotspot Mapper",
                description: "City police use DBSCAN to identify crime clusters and patrol zones from incident GPS coordinates, ignoring isolated events.",
                algorithm: "DBSCAN",
                useCases: ["Patrol route optimization", "Resource deployment planning", "Crime prevention strategies"],
                keyPoints: [
                    "Finds irregular-shaped hotspots",
                    "Filters random incidents as noise",
                    "Adapts to city geography"
                ],
                icon: "üöî"
            },
            {
                id: 11,
                category: "Unsupervised",
                title: "Quantum Data Denoiser",
                description: "A quantum research lab uses Gaussian Mixture Models to separate pure quantum signals from thermal noise and environmental interference in sensor measurements.",
                algorithm: "Gaussian Mixture Model",
                useCases: ["Quantum signal purification", "Noise component identification", "Measurement quality assessment"],
                keyPoints: [
                    "Separates 3 signal components automatically",
                    "Identifies pure vs corrupted quantum states",
                    "Achieves 95%+ denoising accuracy"
                ],
                icon: "‚öõÔ∏è"
            },
            
            // Reinforcement Learning
            {
                id: 12,
                category: "RL",
                title: "Warehouse Robot Navigator",
                description: "An e-commerce fulfillment center trains robots with Q-Learning to find optimal paths through dynamic warehouse layouts.",
                algorithm: "Q-Learning",
                useCases: ["Fastest picking routes", "Collision avoidance", "Adapting to layout changes"],
                keyPoints: [
                    "Learns from trial and error",
                    "Handles moving obstacles",
                    "Reduced picking time by 40%"
                ],
                icon: "ü§ñ"
            },
            {
                id: 13,
                category: "RL",
                title: "Virtual Racing Champion",
                description: "A game studio uses DQN to create unbeatable AI opponents that learn racing lines and overtaking strategies from millions of gameplay sessions.",
                algorithm: "Deep Q-Network",
                useCases: ["Adaptive difficulty scaling", "Player training mode", "Tournament-level AI"],
                keyPoints: [
                    "Masters complex 3D environments",
                    "Learns from visual input only",
                    "Beats 98% of human players"
                ],
                icon: "üèéÔ∏è"
            },
            {
                id: 14,
                category: "RL",
                title: "Renewable Energy Grid Optimizer",
                description: "A smart grid uses Policy Gradient to balance solar/wind power distribution, learning to minimize costs while meeting real-time demand.",
                algorithm: "Policy Gradient",
                useCases: ["Peak load management", "Battery storage optimization", "Carbon footprint reduction"],
                keyPoints: [
                    "Continuous action space (0-100% allocation)",
                    "Adapts to weather patterns",
                    "Saves $2M annually in costs"
                ],
                icon: "‚ö°"
            },
            {
                id: 15,
                category: "RL",
                title: "Space Station Arm Controller",
                description: "ISS robotic arms use Actor-Critic to perform delicate satellite repairs, learning precise movements in zero-gravity microgravity conditions.",
                algorithm: "Actor-Critic",
                useCases: ["Satellite capture and repair", "Cargo module docking", "External maintenance tasks"],
                keyPoints: [
                    "Sub-millimeter precision required",
                    "Stable learning in simulations",
                    "Transferred to real hardware"
                ],
                icon: "üõ∞Ô∏è"
            },
            {
                id: 16,
                category: "RL",
                title: "Clinical Trial Dose Finder",
                description: "Pharmaceutical researchers use Multi-Armed Bandit to dynamically adjust drug dosages across patient groups, maximizing efficacy while minimizing side effects.",
                algorithm: "Multi-Armed Bandit",
                useCases: ["Adaptive dosing protocols", "Patient safety optimization", "Accelerated trial completion"],
                keyPoints: [
                    "Balances exploration vs exploitation",
                    "Ethical early stopping criteria",
                    "Reduced trial time by 6 months"
                ],
                icon: "üíä"
            }
        ];

        // ===== MAIN APP COMPONENT =====
        function MLRulesViewer() {
            const [selectedCategory, setSelectedCategory] = useState('All');
            const [searchTerm, setSearchTerm] = useState('');
            const [expandedCard, setExpandedCard] = useState(null);
            const [currentView, setCurrentView] = useState('home');
            const [selectedExample, setSelectedExample] = useState(null);

            const categories = ['All', 'Supervised', 'Unsupervised', 'RL'];

            const getCategoryColor = (category) => {
                switch (category) {
                    case 'Supervised':
                        return {
                            bg: 'bg-blue-100',
                            border: 'border-blue-500',
                            text: 'text-blue-700',
                            badge: 'bg-blue-500',
                            hover: 'hover:bg-blue-50'
                        };
                    case 'Unsupervised':
                        return {
                            bg: 'bg-green-100',
                            border: 'border-green-500',
                            text: 'text-green-700',
                            badge: 'bg-green-500',
                            hover: 'hover:bg-green-50'
                        };
                    case 'RL':
                        return {
                            bg: 'bg-purple-100',
                            border: 'border-purple-500',
                            text: 'text-purple-700',
                            badge: 'bg-purple-500',
                            hover: 'hover:bg-purple-50'
                        };
                    default:
                        return {
                            bg: 'bg-gray-100',
                            border: 'border-gray-500',
                            text: 'text-gray-700',
                            badge: 'bg-gray-500',
                            hover: 'hover:bg-gray-50'
                        };
                }
            };

            const filteredModules = mlModulesContent.filter(module => {
                const matchesCategory = selectedCategory === 'All' || module.category === selectedCategory;
                const matchesSearch = module.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                    module.description.toLowerCase().includes(searchTerm.toLowerCase());
                return matchesCategory && matchesSearch;
            });

            const getCategoryStats = () => {
                const supervised = mlModulesContent.filter(m => m.category === 'Supervised').length;
                const unsupervised = mlModulesContent.filter(m => m.category === 'Unsupervised').length;
                const rl = mlModulesContent.filter(m => m.category === 'RL').length;
                return { supervised, unsupervised, rl };
            };

            const stats = getCategoryStats();

            const handleExampleClick = (example) => {
                setSelectedExample(example);
                setCurrentView('example');
            };

            const handleBackToHome = () => {
                setCurrentView('home');
                setSelectedExample(null);
            };

            if (currentView === 'example' && selectedExample) {
                return React.createElement(MLExamplePageWrapper, {
                    example: selectedExample,
                    onBack: handleBackToHome
                });
            }

            return React.createElement('div', {
                className: 'min-h-screen bg-gray-50'
            }, [
                React.createElement('header', {
                    key: 'header',
                    className: 'gradient-bg text-white shadow-lg'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-8 sm:py-12'
                    }, [
                        React.createElement('h1', {
                            key: 'title',
                            className: 'text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-3'
                        }, 'ü§ñ ML Science Explorer'),
                        React.createElement('p', {
                            key: 'subtitle',
                            className: 'text-center text-sm sm:text-base md:text-lg opacity-90 max-w-2xl mx-auto'
                        }, 'Your interactive guide to Machine Learning algorithms and applications'),
                        
                        React.createElement('div', {
                            key: 'stats',
                            className: 'mt-6 grid grid-cols-3 gap-2 sm:gap-4 max-w-2xl mx-auto'
                        }, [
                            React.createElement('div', {
                                key: 'supervised',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.supervised),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Supervised')
                            ]),
                            React.createElement('div', {
                                key: 'unsupervised',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.unsupervised),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Unsupervised')
                            ]),
                            React.createElement('div', {
                                key: 'rl',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.rl),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Reinforcement')
                            ])
                        ])
                    ])
                ),

                React.createElement('div', {
                    key: 'controls',
                    className: 'sticky top-0 bg-white shadow-md z-10'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-4'
                    }, [
                        React.createElement('div', {
                            key: 'search',
                            className: 'mb-4'
                        }, 
                            React.createElement('input', {
                                type: 'text',
                                placeholder: 'üîç Search algorithms...',
                                value: searchTerm,
                                onChange: (e) => setSearchTerm(e.target.value),
                                className: 'w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none transition-colors text-sm sm:text-base'
                            })
                        ),

                        React.createElement('div', {
                            key: 'filters',
                            className: 'flex flex-wrap gap-2'
                        }, 
                            categories.map(category => {
                                const colors = getCategoryColor(category === 'All' ? 'default' : category);
                                const isActive = selectedCategory === category;
                                return React.createElement('button', {
                                    key: category,
                                    onClick: () => setSelectedCategory(category),
                                    className: `px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                        isActive
                                            ? `${colors.badge} text-white shadow-md`
                                            : `${colors.bg} ${colors.text} ${colors.hover}`
                                    }`
                                }, [
                                    category,
                                    category !== 'All' && React.createElement('span', {
                                        key: 'count',
                                        className: 'ml-2 opacity-75'
                                    }, `(${category === 'Supervised' ? stats.supervised : 
                                         category === 'Unsupervised' ? stats.unsupervised : 
                                         stats.rl})`)
                                ]);
                            })
                        )
                    ])
                ),

                React.createElement('main', {
                    key: 'main',
                    className: 'container mx-auto px-4 py-8'
                }, 
                    filteredModules.length === 0 ? 
                        React.createElement('div', {
                            className: 'text-center py-12'
                        }, [
                            React.createElement('div', {
                                key: 'icon',
                                className: 'text-6xl mb-4'
                            }, 'üîç'),
                            React.createElement('h3', {
                                key: 'title',
                                className: 'text-xl sm:text-2xl font-semibold text-gray-700 mb-2'
                            }, 'No algorithms found'),
                            React.createElement('p', {
                                key: 'desc',
                                className: 'text-gray-500'
                            }, 'Try adjusting your search or filter criteria')
                        ]) :
                        React.createElement('div', {
                            className: 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6'
                        }, 
                            filteredModules.map((module, index) => {
                                const colors = getCategoryColor(module.category);
                                
                                return React.createElement('div', {
                                    key: module.id,
                                    className: `bg-white rounded-xl shadow-md border-l-4 ${colors.border} card-hover fade-in overflow-hidden cursor-pointer`,
                                    style: { animationDelay: `${index * 0.05}s` },
                                    onClick: () => handleExampleClick(module)
                                }, [
                                    React.createElement('div', {
                                        key: 'header',
                                        className: `${colors.bg} p-4`
                                    }, 
                                        React.createElement('div', {
                                            className: 'flex items-start justify-between'
                                        }, 
                                            React.createElement('div', {
                                                className: 'flex-1'
                                            }, [
                                                React.createElement('div', {
                                                    key: 'badges',
                                                    className: 'flex items-center gap-2 mb-2'
                                                }, [
                                                    React.createElement('span', {
                                                        key: 'icon',
                                                        className: 'text-3xl'
                                                    }, module.icon),
                                                    React.createElement('span', {
                                                        key: 'badge',
                                                        className: `${colors.badge} text-white text-xs font-bold px-2 py-1 rounded`
                                                    }, module.category)
                                                ]),
                                                React.createElement('h3', {
                                                    key: 'title',
                                                    className: `text-lg sm:text-xl font-bold ${colors.text}`
                                                }, module.title)
                                            ])
                                        )
                                    ),

                                    React.createElement('div', {
                                        key: 'body',
                                        className: 'p-4'
                                    }, [
                                        React.createElement('p', {
                                            key: 'description',
                                            className: 'text-gray-700 text-sm sm:text-base mb-4'
                                        }, module.description),

                                        React.createElement('div', {
                                            key: 'key-points',
                                            className: 'mb-4'
                                        }, [
                                            React.createElement('h4', {
                                                key: 'kp-title',
                                                className: 'font-semibold text-gray-900 mb-2 text-sm'
                                            }, '‚ú® Key Points:'),
                                            React.createElement('ul', {
                                                key: 'kp-list',
                                                className: 'space-y-1'
                                            }, 
                                                module.keyPoints.slice(0, 2).map((point, idx) =>
                                                    React.createElement('li', {
                                                        key: idx,
                                                        className: 'text-xs sm:text-sm text-gray-600 flex items-start'
                                                    }, [
                                                        React.createElement('span', {
                                                            key: 'bullet',
                                                            className: `${colors.text} mr-2`
                                                        }, '‚Ä¢'),
                                                        point
                                                    ])
                                                )
                                            )
                                        ]),

                                        React.createElement('div', {
                                            key: 'cta',
                                            className: 'mt-4'
                                        }, 
                                            React.createElement('button', {
                                                className: `w-full text-center font-semibold text-sm ${colors.text} ${colors.hover} p-2 rounded transition-colors flex items-center justify-center gap-2`
                                            }, [
                                                React.createElement('span', { key: 'text' }, 'üìä View Interactive Example'),
                                                React.createElement('span', { key: 'arrow' }, '‚Üí')
                                            ])
                                        )
                                    ])
                                ]);
                            })
                        )
                )
            ]);
        }

        // ===== ML EXAMPLE PAGE WRAPPER =====
        function MLExamplePageWrapper({ example, onBack }) {
            const [data, setData] = useState([]);
            const [charts, setCharts] = useState([]);

            useEffect(() => {
                generateExampleData(example);
            }, [example]);

            const generateExampleData = (example) => {
                let generatedData = [];
                let generatedCharts = [];

                try {
                    switch (example.id) {
                        case 1: // Vineyard
                            generatedData = dataGenerators.vineyard(200);
                            generatedCharts = [
                                {
                                    title: "Yield vs Rainfall Correlation",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'rainfall',
                                        yField: 'yield_tons',
                                        title: 'Vineyard Yield vs Rainfall',
                                        xLabel: 'Rainfall (inches)',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-1'
                                    })
                                },
                                {
                                    title: "Temperature Impact Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'temperature',
                                        yField: 'yield_tons',
                                        title: 'Yield vs Temperature',
                                        xLabel: 'Average Temperature (¬∞F)',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-2'
                                    })
                                },
                                {
                                    title: "Soil pH Effects",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'soilPH',
                                        yField: 'yield_tons',
                                        title: 'Yield vs Soil pH',
                                        xLabel: 'Soil pH Level',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-3'
                                    })
                                }
                            ];
                            break;

                        case 2: // Dragon Egg
                            generatedData = dataGenerators.dragonEgg(300);
                            generatedCharts = [
                                {
                                    title: "Hatching Success by Temperature & Magical Aura",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'temperature',
                                        yField: 'magicalAura',
                                        colorField: 'hatched',
                                        title: 'Dragon Egg Hatching Patterns',
                                        xLabel: 'Incubation Temperature (¬∞F)',
                                        yLabel: 'Magical Aura Level',
                                        canvasId: 'dragon-scatter-1'
                                    })
                                },
                                {
                                    title: "Egg Type Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, egg) => {
                                            acc[egg.eggType] = (acc[egg.eggType] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Dragon Egg Types in Collection',
                                        canvasId: 'dragon-pie-1'
                                    })
                                },
                                {
                                    title: "Hatch Rate by Egg Type",
                                    component: React.createElement(BarChart, {
                                        data: Object.entries(generatedData.reduce((acc, egg) => {
                                            if (!acc[egg.eggType]) acc[egg.eggType] = { total: 0, hatched: 0 };
                                            acc[egg.eggType].total++;
                                            if (egg.hatched) acc[egg.eggType].hatched++;
                                            return acc;
                                        }, {})).map(([type, stats]) => ({ 
                                            eggType: type, 
                                            hatchRate: Math.round((stats.hatched / stats.total) * 100) 
                                        })),
                                        xField: 'eggType',
                                        yField: 'hatchRate',
                                        title: 'Success Rate by Dragon Type (%)',
                                        xLabel: 'Dragon Egg Type',
                                        yLabel: 'Hatch Success Rate (%)',
                                        canvasId: 'dragon-bar-1',
                                        color: chartUtils.colors.purple
                                    })
                                },
                                {
                                    title: "Parent Dragon Age vs Hatch Success",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'dragonAge',
                                        yField: 'hatchProbability',
                                        colorField: 'eggType',
                                        title: 'Dragon Age Influence on Hatching',
                                        xLabel: 'Parent Dragon Age (years)',
                                        yLabel: 'Hatch Probability',
                                        canvasId: 'dragon-scatter-2'
                                    })
                                }
                            ];
                            break;

                        case 3: // Streaming
                            generatedData = dataGenerators.streaming(500);
                            generatedCharts = [
                                {
                                    title: "Genre Recommendations by Time",
                                    component: React.createElement(BarChart, {
                                        data: Object.entries(generatedData.reduce((acc, session) => {
                                            acc[session.recommendedGenre] = (acc[session.recommendedGenre] || 0) + 1;
                                            return acc;
                                        }, {})).map(([genre, count]) => ({ genre, count })),
                                        xField: 'genre',
                                        yField: 'count',
                                        title: 'Genre Recommendation Frequency',
                                        xLabel: 'Genre',
                                        yLabel: 'Recommendations',
                                        canvasId: 'streaming-bar-1'
                                    })
                                }
                            ];
                            break;

                        case 4: // Insurance
                            generatedData = dataGenerators.insurance(400);
                            generatedCharts = [
                                {
                                    title: "Fraud Detection Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'claimAmount',
                                        yField: 'timeToReport',
                                        colorField: 'isFraud',
                                        title: 'Claim Amount vs Reporting Time',
                                        xLabel: 'Claim Amount ($)',
                                        yLabel: 'Days to Report',
                                        canvasId: 'insurance-scatter-1'
                                    })
                                },
                                {
                                    title: "Fraud vs Legitimate Claims",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, claim) => {
                                            const type = claim.isFraud ? 'Fraudulent' : 'Legitimate';
                                            acc[type] = (acc[type] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Claim Types Distribution',
                                        canvasId: 'insurance-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 5: // Asteroid
                            generatedData = dataGenerators.asteroid(150);
                            generatedCharts = [
                                {
                                    title: "Spectral Feature Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'spectralFeature1',
                                        yField: 'spectralFeature2',
                                        colorField: 'asteroidType',
                                        title: 'Spectral Features Classification',
                                        xLabel: 'Reflectance Feature',
                                        yLabel: 'Absorption Feature',
                                        canvasId: 'asteroid-scatter-1'
                                    })
                                },
                                {
                                    title: "Asteroid Type Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, asteroid) => {
                                            acc[asteroid.asteroidType] = (acc[asteroid.asteroidType] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Asteroid Types',
                                        canvasId: 'asteroid-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 6: // Medical
                            generatedData = dataGenerators.medical(250);
                            generatedCharts = [
                                {
                                    title: "Image Feature Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'brightness',
                                        yField: 'contrast',
                                        colorField: 'hasTumor',
                                        title: 'Brightness vs Contrast Analysis',
                                        xLabel: 'Image Brightness',
                                        yLabel: 'Image Contrast',
                                        canvasId: 'medical-scatter-1'
                                    })
                                },
                                {
                                    title: "Diagnostic Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, scan) => {
                                            const diagnosis = scan.hasTumor ? 'Tumor Detected' : 'Clear';
                                            acc[diagnosis] = (acc[diagnosis] || 0) + 1;
                                            return acc;
                                        }, {})).map(([diagnosis, count]) => ({ diagnosis, count })),
                                        labelField: 'diagnosis',
                                        valueField: 'count',
                                        title: 'Medical Diagnoses',
                                        canvasId: 'medical-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 7: // Retail Customer Segmentation
                            generatedData = dataGenerators.retail(300);
                            const segmentCounts = generatedData.reduce((acc, customer) => {
                                acc[customer.segment] = (acc[customer.segment] || 0) + 1;
                                return acc;
                            }, {});
                            
                            const segmentData = Object.entries(segmentCounts).map(([segment, count]) => ({
                                segment,
                                count
                            }));

                            generatedCharts = [
                                {
                                    title: "Customer Segment Distribution",
                                    component: React.createElement(PieChart, {
                                        data: segmentData,
                                        labelField: 'segment',
                                        valueField: 'count',
                                        title: 'Customer Segments',
                                        canvasId: 'retail-pie-1'
                                    })
                                },
                                {
                                    title: "Spending vs Purchase Frequency",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'monthlySpend',
                                        yField: 'purchaseFrequency',
                                        colorField: 'segment',
                                        title: 'Customer Behavior Patterns',
                                        xLabel: 'Monthly Spend ($)',
                                        yLabel: 'Purchase Frequency',
                                        canvasId: 'retail-scatter-1'
                                    })
                                }
                            ];
                            break;

                        case 8: // Evolutionary Tree
                            generatedData = dataGenerators.evolutionary(25);
                            generatedCharts = [
                                {
                                    title: "Species DNA Similarity",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'dnaSequence1',
                                        yField: 'dnaSequence2',
                                        colorField: 'category',
                                        title: 'DNA Sequence Analysis',
                                        xLabel: 'DNA Sequence 1',
                                        yLabel: 'DNA Sequence 2',
                                        canvasId: 'evolution-scatter-1'
                                    })
                                },
                                {
                                    title: "Species Category Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, species) => {
                                            acc[species.category] = (acc[species.category] || 0) + 1;
                                            return acc;
                                        }, {})).map(([category, count]) => ({ category, count })),
                                        labelField: 'category',
                                        valueField: 'count',
                                        title: 'Species Categories',
                                        canvasId: 'evolution-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 9: // AI Art Style Compressor
                            generatedData = dataGenerators.artCompressor(500);
                            generatedCharts = [
                                {
                                    title: "Principal Component Analysis - Style Dimensions",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'pc1',
                                        yField: 'pc2',
                                        colorField: 'artStyle',
                                        title: 'PC1 vs PC2 - Art Style Clusters',
                                        xLabel: 'Principal Component 1 (Classical vs Modern)',
                                        yLabel: 'Principal Component 2 (Realistic vs Abstract)',
                                        canvasId: 'art-scatter-1'
                                    })
                                },
                                {
                                    title: "Medium Classification in PC Space",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'pc2',
                                        yField: 'pc3',
                                        colorField: 'medium',
                                        title: 'PC2 vs PC3 - Medium Separation',
                                        xLabel: 'Principal Component 2 (Realistic vs Abstract)',
                                        yLabel: 'Principal Component 3 (Traditional vs Digital)',
                                        canvasId: 'art-scatter-2'
                                    })
                                },
                                {
                                    title: "Variance Explained by Principal Components",
                                    component: React.createElement(BarChart, {
                                        data: [
                                            { component: 'PC1', variance: 32.4 },
                                            { component: 'PC2', variance: 18.7 },
                                            { component: 'PC3', variance: 12.3 },
                                            { component: 'PC4', variance: 8.9 },
                                            { component: 'PC5', variance: 6.2 },
                                            { component: 'PC6', variance: 4.8 },
                                            { component: 'PC7', variance: 3.7 },
                                            { component: 'PC8', variance: 2.9 },
                                            { component: 'PC9', variance: 2.4 },
                                            { component: 'PC10', variance: 1.9 }
                                        ],
                                        xField: 'component',
                                        yField: 'variance',
                                        title: 'Explained Variance by Component (%)',
                                        xLabel: 'Principal Component',
                                        yLabel: 'Variance Explained (%)',
                                        canvasId: 'art-bar-1',
                                        color: chartUtils.colors.purple
                                    })
                                },
                                {
                                    title: "Cumulative Variance Explained",
                                    component: React.createElement(LineChart, {
                                        data: [
                                            { component: 1, cumulative: 32.4 },
                                            { component: 2, cumulative: 51.1 },
                                            { component: 3, cumulative: 63.4 },
                                            { component: 4, cumulative: 72.3 },
                                            { component: 5, cumulative: 78.5 },
                                            { component: 6, cumulative: 83.3 },
                                            { component: 7, cumulative: 87.0 },
                                            { component: 8, cumulative: 89.9 },
                                            { component: 9, cumulative: 92.3 },
                                            { component: 10, cumulative: 94.2 }
                                        ],
                                        xField: 'component',
                                        yField: 'cumulative',
                                        title: 'Cumulative Variance Explained (%)',
                                        xLabel: 'Number of Components',
                                        yLabel: 'Cumulative Variance (%)',
                                        canvasId: 'art-line-1',
                                        color: chartUtils.colors.success
                                    })
                                },
                                {
                                    title: "Art Style Distribution in Dataset",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, artwork) => {
                                            acc[artwork.artStyle] = (acc[artwork.artStyle] || 0) + 1;
                                            return acc;
                                        }, {})).map(([style, count]) => ({ style, count })),
                                        labelField: 'style',
                                        valueField: 'count',
                                        title: 'Artwork Styles in Collection',
                                        canvasId: 'art-pie-1'
                                    })
                                },
                                {
                                    title: "Compression Efficiency Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.map(artwork => ({
                                            ...artwork,
                                            compressionEfficiency: artwork.similarityScore * 100,
                                            errorRate: artwork.reconstructionError * 100
                                        })),
                                        xField: 'compressionEfficiency',
                                        yField: 'errorRate',
                                        colorField: 'artStyle',
                                        title: 'Compression Quality vs Reconstruction Error',
                                        xLabel: 'Similarity Score (%)',
                                        yLabel: 'Reconstruction Error (%)',
                                        canvasId: 'art-scatter-3'
                                    })
                                },
                                {
                                    title: "Search Performance Improvement",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const avgSpeedUp = generatedData.reduce((acc, curr) => acc + curr.searchSpeedUp, 0) / generatedData.length;
                                            return [
                                                { method: 'Original Features\n(2048 dims)', searchTime: 100, efficiency: 'Baseline' },
                                                { method: 'PCA Compressed\n(10 dims)', searchTime: Math.round(100 / avgSpeedUp * 10) / 10, efficiency: 'Optimized' }
                                            ];
                                        })(),
                                        xField: 'method',
                                        yField: 'searchTime',
                                        title: 'Search Time Comparison (Relative %)',
                                        xLabel: 'Feature Space Method',
                                        yLabel: 'Relative Search Time (%)',
                                        canvasId: 'art-bar-2',
                                        color: chartUtils.colors.danger
                                    })
                                }
                            ];
                            break;

                        case 10: // Urban Crime Hotspot Mapper
                            generatedData = dataGenerators.crimeHotspot(600);
                            generatedCharts = [
                                {
                                    title: "Crime Hotspot Geographic Clustering",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'longitude',
                                        yField: 'latitude',
                                        colorField: 'dbscanCluster',
                                        title: 'DBSCAN Crime Clusters - Geographic View',
                                        xLabel: 'Longitude',
                                        yLabel: 'Latitude',
                                        canvasId: 'crime-scatter-1'
                                    })
                                },
                                {
                                    title: "Cluster Type Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'longitude',
                                        yField: 'latitude',
                                        colorField: 'clusterType',
                                        title: 'DBSCAN Point Types (Core, Border, Noise)',
                                        xLabel: 'Longitude',
                                        yLabel: 'Latitude',
                                        canvasId: 'crime-scatter-2'
                                    })
                                },
                                {
                                    title: "Crime Type Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, incident) => {
                                            acc[incident.crimeType] = (acc[incident.crimeType] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Crime Types in Dataset',
                                        canvasId: 'crime-pie-1'
                                    })
                                },
                                {
                                    title: "Patrol Priority by Cluster Analysis",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const priorityStats = generatedData.reduce((acc, incident) => {
                                                if (!acc[incident.patrolPriority]) {
                                                    acc[incident.patrolPriority] = { count: 0, totalResource: 0 };
                                                }
                                                acc[incident.patrolPriority].count++;
                                                acc[incident.patrolPriority].totalResource += incident.resourceScore;
                                                return acc;
                                            }, {});
                                            
                                            return Object.entries(priorityStats).map(([priority, stats]) => ({
                                                priority,
                                                count: stats.count,
                                                avgResource: Math.round(stats.totalResource / stats.count)
                                            }));
                                        })(),
                                        xField: 'priority',
                                        yField: 'count',
                                        title: 'Incidents by Patrol Priority',
                                        xLabel: 'Patrol Priority Level',
                                        yLabel: 'Number of Incidents',
                                        canvasId: 'crime-bar-1',
                                        color: chartUtils.colors.danger
                                    })
                                },
                                {
                                    title: "Density vs Distance Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter(incident => !incident.isNoise),
                                        xField: 'corePointDistance',
                                        yField: 'densityScore',
                                        colorField: 'severity',
                                        title: 'Distance to Core vs Density Score',
                                        xLabel: 'Distance to Nearest Core Point',
                                        yLabel: 'DBSCAN Density Score',
                                        canvasId: 'crime-scatter-3'
                                    })
                                },
                                {
                                    title: "Response Time vs Population Density",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'populationDensity',
                                        yField: 'responseTime',
                                        colorField: 'clusterType',
                                        title: 'Emergency Response Efficiency Analysis',
                                        xLabel: 'Population Density (per sq km)',
                                        yLabel: 'Response Time (minutes)',
                                        canvasId: 'crime-scatter-4'
                                    })
                                },
                                {
                                    title: "Noise vs Clustered Incidents",
                                    component: React.createElement(PieChart, {
                                        data: (() => {
                                            const clustered = generatedData.filter(incident => !incident.isNoise).length;
                                            const noise = generatedData.filter(incident => incident.isNoise).length;
                                            return [
                                                { category: 'Clustered Hotspots', count: clustered },
                                                { category: 'Isolated Incidents (Noise)', count: noise }
                                            ];
                                        })(),
                                        labelField: 'category',
                                        valueField: 'count',
                                        title: 'DBSCAN Classification Results',
                                        canvasId: 'crime-pie-2'
                                    })
                                },
                                {
                                    title: "Crime Probability Prediction by Area",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const areaStats = generatedData.reduce((acc, incident) => {
                                                if (!acc[incident.hotspotCenter]) {
                                                    acc[incident.hotspotCenter] = { 
                                                        totalProb: 0, 
                                                        count: 0,
                                                        incidents: 0
                                                    };
                                                }
                                                acc[incident.hotspotCenter].totalProb += incident.crimeProbability;
                                                acc[incident.hotspotCenter].count++;
                                                acc[incident.hotspotCenter].incidents++;
                                                return acc;
                                            }, {});
                                            
                                            return Object.entries(areaStats)
                                                .map(([area, stats]) => ({
                                                    area: area.length > 15 ? area.substring(0, 12) + '...' : area,
                                                    avgProbability: Math.round((stats.totalProb / stats.count) * 100),
                                                    incidents: stats.incidents
                                                }))
                                                .sort((a, b) => b.avgProbability - a.avgProbability);
                                        })(),
                                        xField: 'area',
                                        yField: 'avgProbability',
                                        title: 'Crime Probability by Area Type (%)',
                                        xLabel: 'Area Type',
                                        yLabel: 'Average Crime Probability (%)',
                                        canvasId: 'crime-bar-2',
                                        color: chartUtils.colors.purple
                                    })
                                }
                            ];
                            break;

                        case 11: // Quantum Data Denoiser
                            generatedData = dataGenerators.quantumDenoiser(800);
                            generatedCharts = [
                                {
                                    title: "GMM Component Separation - Amplitude vs Phase",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'amplitude',
                                        yField: 'phase',
                                        colorField: 'assignedComponent',
                                        title: 'Quantum Signal Components in Phase Space',
                                        xLabel: 'Signal Amplitude',
                                        yLabel: 'Phase (radians)',
                                        canvasId: 'quantum-scatter-1'
                                    })
                                },
                                {
                                    title: "Signal Quality Distribution",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'fidelity',
                                        yField: 'snr',
                                        colorField: 'assignedComponent',
                                        title: 'Fidelity vs Signal-to-Noise Ratio',
                                        xLabel: 'Quantum State Fidelity',
                                        yLabel: 'Signal-to-Noise Ratio (dB)',
                                        canvasId: 'quantum-scatter-2'
                                    })
                                },
                                {
                                    title: "GMM Component Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, measurement) => {
                                            acc[measurement.assignedComponent] = (acc[measurement.assignedComponent] || 0) + 1;
                                            return acc;
                                        }, {})).map(([component, count]) => ({ component, count })),
                                        labelField: 'component',
                                        valueField: 'count',
                                        title: 'Quantum Measurement Components',
                                        canvasId: 'quantum-pie-1'
                                    })
                                },
                                {
                                    title: "Denoising Performance by Component",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const componentStats = generatedData.reduce((acc, measurement) => {
                                                if (!acc[measurement.assignedComponent]) {
                                                    acc[measurement.assignedComponent] = { 
                                                        totalQuality: 0, 
                                                        count: 0,
                                                        totalError: 0
                                                    };
                                                }
                                                acc[measurement.assignedComponent].totalQuality += measurement.denoisingQuality;
                                                acc[measurement.assignedComponent].totalError += measurement.reconstructionError;
                                                acc[measurement.assignedComponent].count++;
                                                return acc;
                                            }, {});
                                            
                                            return Object.entries(componentStats).map(([component, stats]) => ({
                                                component,
                                                avgQuality: Math.round((stats.totalQuality / stats.count) * 100)
                                            }));
                                        })(),
                                        xField: 'component',
                                        yField: 'avgQuality',
                                        title: 'Average Denoising Quality by Component (%)',
                                        xLabel: 'GMM Component',
                                        yLabel: 'Denoising Quality (%)',
                                        canvasId: 'quantum-bar-1',
                                        color: chartUtils.colors.success
                                    })
                                },
                                {
                                    title: "Coherence Time vs Temperature",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'temperature',
                                        yField: 'coherenceTime',
                                        colorField: 'assignedComponent',
                                        title: 'Quantum Decoherence Analysis',
                                        xLabel: 'Temperature (K)',
                                        yLabel: 'Coherence Time (Œºs)',
                                        canvasId: 'quantum-scatter-3'
                                    })
                                },
                                {
                                    title: "Log-Likelihood Distribution",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const likelihoodRanges = {
                                                'High (-5 to 0)': 0,
                                                'Medium (-10 to -5)': 0,
                                                'Low (-15 to -10)': 0,
                                                'Very Low (< -15)': 0
                                            };
                                            
                                            generatedData.forEach(measurement => {
                                                if (measurement.logLikelihood >= -5) likelihoodRanges['High (-5 to 0)']++;
                                                else if (measurement.logLikelihood >= -10) likelihoodRanges['Medium (-10 to -5)']++;
                                                else if (measurement.logLikelihood >= -15) likelihoodRanges['Low (-15 to -10)']++;
                                                else likelihoodRanges['Very Low (< -15)']++;
                                            });
                                            
                                            return Object.entries(likelihoodRanges).map(([range, count]) => ({
                                                range,
                                                count
                                            }));
                                        })(),
                                        xField: 'range',
                                        yField: 'count',
                                        title: 'GMM Log-Likelihood Distribution',
                                        xLabel: 'Log-Likelihood Range',
                                        yLabel: 'Number of Measurements',
                                        canvasId: 'quantum-bar-2',
                                        color: chartUtils.colors.purple
                                    })
                                },
                                {
                                    title: "Detector Efficiency vs Noise Type",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'detectorEfficiency',
                                        yField: 'noiseLevel',
                                        colorField: 'detectorType',
                                        title: 'Detector Performance Analysis',
                                        xLabel: 'Detector Efficiency',
                                        yLabel: 'Noise Level',
                                        canvasId: 'quantum-scatter-4'
                                    })
                                }
                            ];
                            break;

                        case 12: // Warehouse Robot
                            generatedData = dataGenerators.warehouse(100);
                            generatedCharts = [
                                {
                                    title: "Robot Performance Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'optimalSteps',
                                        yField: 'actualSteps',
                                        title: 'Optimal vs Actual Steps',
                                        xLabel: 'Optimal Steps',
                                        yLabel: 'Actual Steps',
                                        canvasId: 'warehouse-scatter-1'
                                    })
                                },
                                {
                                    title: "Mission Rewards Distribution",
                                    component: React.createElement(BarChart, {
                                        data: generatedData.map(d => ({ 
                                            rewardRange: d.reward >= 90 ? '90-100' : 
                                                        d.reward >= 80 ? '80-89' : 
                                                        d.reward >= 70 ? '70-79' : 
                                                        d.reward >= 60 ? '60-69' : 'Below 60',
                                            count: 1 
                                        })).reduce((acc, curr) => {
                                            const existing = acc.find(item => item.rewardRange === curr.rewardRange);
                                            if (existing) existing.count++;
                                            else acc.push(curr);
                                            return acc;
                                        }, []),
                                        xField: 'rewardRange',
                                        yField: 'count',
                                        title: 'Reward Score Distribution',
                                        xLabel: 'Reward Range',
                                        yLabel: 'Number of Missions',
                                        canvasId: 'warehouse-bar-1'
                                    })
                                }
                            ];
                            break;

                        case 13: // Virtual Racing Champion
                            generatedData = dataGenerators.racingAI(1000);
                            generatedCharts = [
                                {
                                    title: "AI Training Progress - Lap Time Improvement",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 25 === 0), // Sample every 25th episode for readability
                                        xField: 'episode',
                                        yField: 'aiLapTime',
                                        title: 'AI Lap Time vs Training Episodes',
                                        xLabel: 'Training Episode',
                                        yLabel: 'AI Lap Time (seconds)',
                                        canvasId: 'racing-line-1',
                                        color: chartUtils.colors.danger
                                    })
                                },
                                {
                                    title: "Win Rate Progress Over Training",
                                    component: React.createElement(LineChart, {
                                        data: (() => {
                                            const windowSize = 50;
                                            const winRateData = [];
                                            for (let i = windowSize; i < generatedData.length; i += windowSize) {
                                                const window = generatedData.slice(i - windowSize, i);
                                                const winRate = (window.filter(race => race.aiWon).length / windowSize) * 100;
                                                winRateData.push({
                                                    episode: i,
                                                    winRate: Math.round(winRate * 10) / 10
                                                });
                                            }
                                            return winRateData;
                                        })(),
                                        xField: 'episode',
                                        yField: 'winRate',
                                        title: 'AI Win Rate Over Time (%)',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Win Rate (%)',
                                        canvasId: 'racing-line-2',
                                        color: chartUtils.colors.success
                                    })
                                },
                                {
                                    title: "Cumulative Reward Learning Curve",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 20 === 0),
                                        xField: 'episode',
                                        yField: 'cumulativeReward',
                                        title: 'Cumulative Reward vs Training Time',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Cumulative Reward',
                                        canvasId: 'racing-line-3',
                                        color: chartUtils.colors.purple
                                    })
                                },
                                {
                                    title: "Q-Value Evolution by Action Type",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 40 === 0).flatMap(race => [
                                            { episode: race.episode, action: 'Accelerate', qValue: race.accelerateQ },
                                            { episode: race.episode, action: 'Brake', qValue: race.brakeQ },
                                            { episode: race.episode, action: 'Turn Left', qValue: race.turnLeftQ },
                                            { episode: race.episode, action: 'Turn Right', qValue: race.turnRightQ },
                                            { episode: race.episode, action: 'Overtake', qValue: race.overtakeQ }
                                        ]),
                                        xField: 'episode',
                                        yField: 'qValue',
                                        colorField: 'action',
                                        title: 'Q-Value Learning for Different Actions',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Q-Value',
                                        canvasId: 'racing-scatter-1'
                                    })
                                },
                                {
                                    title: "Performance by Track Type",
                                    component: React.createElement(BarChart, {
                                        data: Object.entries(generatedData.reduce((acc, race) => {
                                            if (!acc[race.track]) acc[race.track] = { total: 0, wins: 0 };
                                            acc[race.track].total++;
                                            if (race.aiWon) acc[race.track].wins++;
                                            return acc;
                                        }, {})).map(([track, stats]) => ({
                                            track,
                                            winRate: Math.round((stats.wins / stats.total) * 100)
                                        })),
                                        xField: 'track',
                                        yField: 'winRate',
                                        title: 'AI Win Rate by Racing Track (%)',
                                        xLabel: 'Racing Track',
                                        yLabel: 'Win Rate (%)',
                                        canvasId: 'racing-bar-1',
                                        color: chartUtils.colors.info
                                    })
                                },
                                {
                                    title: "Exploration vs Exploitation (Epsilon Decay)",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 30 === 0),
                                        xField: 'episode',
                                        yField: 'epsilon',
                                        title: 'Epsilon-Greedy Exploration Rate',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Epsilon (Exploration Rate)',
                                        canvasId: 'racing-line-4',
                                        color: chartUtils.colors.orange
                                    })
                                }
                            ];
                            break;

                        case 14: // Renewable Energy Grid Optimizer
                            generatedData = dataGenerators.energyGrid(2000);
                            generatedCharts = [
                                {
                                    title: "Energy Demand vs Renewable Generation",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 8 === 0), // Every 8 hours for readability
                                        xField: 'timestamp',
                                        yField: 'energyDemand',
                                        title: 'Daily Energy Demand Pattern',
                                        xLabel: 'Time (hours)',
                                        yLabel: 'Energy Demand (MW)',
                                        canvasId: 'energy-line-1',
                                        color: chartUtils.colors.danger
                                    })
                                },
                                {
                                    title: "Policy Learning Progress - Cost Optimization",
                                    component: React.createElement(LineChart, {
                                        data: (() => {
                                            const windowSize = 48; // 2-day moving average
                                            const costData = [];
                                            for (let i = windowSize; i < generatedData.length; i += windowSize) {
                                                const window = generatedData.slice(i - windowSize, i);
                                                const avgCost = window.reduce((sum, d) => sum + d.totalCost, 0) / windowSize;
                                                costData.push({
                                                    timestamp: i,
                                                    avgCost: Math.round(avgCost * 100) / 100
                                                });
                                            }
                                            return costData;
                                        })(),
                                        xField: 'timestamp',
                                        yField: 'avgCost',
                                        title: 'Average Cost Reduction Over Time',
                                        xLabel: 'Training Time (hours)',
                                        yLabel: 'Average Cost ($)',
                                        canvasId: 'energy-line-2',
                                        color: chartUtils.colors.success
                                    })
                                },
                                {
                                    title: "Renewable Energy Mix Optimization",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 12 === 0).map(d => [
                                            { timestamp: d.timestamp, source: 'Solar', generation: d.solarGeneration, policy: d.solarPolicy },
                                            { timestamp: d.timestamp, source: 'Wind', generation: d.windGeneration, policy: d.windPolicy },
                                            { timestamp: d.timestamp, source: 'Hydro', generation: d.hydroGeneration, policy: 1.0 }
                                        ]).flat(),
                                        xField: 'timestamp',
                                        yField: 'generation',
                                        colorField: 'source',
                                        title: 'Energy Generation by Source Over Time',
                                        xLabel: 'Time (hours)',
                                        yLabel: 'Generation (MW)',
                                        canvasId: 'energy-scatter-1'
                                    })
                                },
                                {
                                    title: "Policy Action Distribution",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 20 === 0),
                                        xField: 'solarPolicy',
                                        yField: 'windPolicy',
                                        colorField: 'season',
                                        title: 'Solar vs Wind Policy Actions by Season',
                                        xLabel: 'Solar Allocation Policy (0-1)',
                                        yLabel: 'Wind Allocation Policy (0-1)',
                                        canvasId: 'energy-scatter-2'
                                    })
                                },
                                {
                                    title: "Renewable Percentage Achievement",
                                    component: React.createElement(LineChart, {
                                        data: (() => {
                                            const windowSize = 24; // Daily averages
                                            const renewableData = [];
                                            for (let i = windowSize; i < generatedData.length; i += windowSize) {
                                                const window = generatedData.slice(i - windowSize, i);
                                                const avgRenewable = window.reduce((sum, d) => sum + d.renewablePercentage, 0) / windowSize;
                                                renewableData.push({
                                                    day: Math.floor(i / 24),
                                                    renewablePercentage: Math.round(avgRenewable * 10) / 10
                                                });
                                            }
                                            return renewableData;
                                        })(),
                                        xField: 'day',
                                        yField: 'renewablePercentage',
                                        title: 'Daily Renewable Energy Percentage',
                                        xLabel: 'Training Day',
                                        yLabel: 'Renewable Energy (%)',
                                        canvasId: 'energy-line-3',
                                        color: chartUtils.colors.teal
                                    })
                                },
                                {
                                    title: "Battery Policy Learning",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 16 === 0),
                                        xField: 'energyDemand',
                                        yField: 'batteryPolicy',
                                        colorField: 'hour',
                                        title: 'Battery Charge/Discharge Policy vs Demand',
                                        xLabel: 'Energy Demand (MW)',
                                        yLabel: 'Battery Policy (-1=Charge, +1=Discharge)',
                                        canvasId: 'energy-scatter-3'
                                    })
                                },
                                {
                                    title: "Cumulative Reward and Cost Savings",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 24 === 0), // Daily samples
                                        xField: 'timestamp',
                                        yField: 'cumulativeReward',
                                        title: 'Cumulative Policy Gradient Reward',
                                        xLabel: 'Time (hours)',
                                        yLabel: 'Cumulative Reward ($)',
                                        canvasId: 'energy-line-4',
                                        color: chartUtils.colors.purple
                                    })
                                }
                            ];
                            break;

                        case 15: // Space Station Arm Controller
                            generatedData = dataGenerators.spaceArm(1200);
                            generatedCharts = [
                                {
                                    title: "Actor-Critic Learning Progress - Mission Success Rate",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 20 === 0), // Sample every 20th episode
                                        xField: 'episode',
                                        yField: 'successRateWindow',
                                        title: 'Mission Success Rate Over Training Episodes (%)',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Success Rate (%)',
                                        canvasId: 'space-line-1',
                                        color: chartUtils.colors.success
                                    })
                                },
                                {
                                    title: "6-DOF Action Space Distribution",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 10 === 0),
                                        xField: 'actionX',
                                        yField: 'actionY',
                                        colorField: 'missionType',
                                        title: 'X-Y Translation Actions by Mission Type',
                                        xLabel: 'X-Axis Action (-1 to 1)',
                                        yLabel: 'Y-Axis Action (-1 to 1)',
                                        canvasId: 'space-scatter-1'
                                    })
                                },
                                {
                                    title: "Precision Achievement vs Training Progress",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 15 === 0),
                                        xField: 'trainingProgress',
                                        yField: 'precisionAchieved',
                                        colorField: 'targetFragility',
                                        title: 'Precision Learning by Target Fragility',
                                        xLabel: 'Training Progress (0-1)',
                                        yLabel: 'Precision Achieved (meters)',
                                        canvasId: 'space-scatter-2'
                                    })
                                },
                                {
                                    title: "Actor vs Critic Loss Convergence",
                                    component: React.createElement(LineChart, {
                                        data: (() => {
                                            const sampledData = generatedData.filter((_, index) => index % 25 === 0);
                                            return sampledData.map(d => ({ episode: d.episode, loss: d.actorLoss, type: 'Actor' }))
                                                .concat(sampledData.map(d => ({ episode: d.episode, loss: d.criticLoss, type: 'Critic' })));
                                        })(),
                                        xField: 'episode',
                                        yField: 'loss',
                                        colorField: 'type',
                                        title: 'Actor-Critic Loss Functions During Training',
                                        xLabel: 'Training Episode',
                                        yLabel: 'Loss Value',
                                        canvasId: 'space-line-2',
                                        color: chartUtils.colors.purple
                                    })
                                },
                                {
                                    title: "Mission Type Performance Analysis",
                                    component: React.createElement(BarChart, {
                                        data: (() => {
                                            const missionStats = generatedData.reduce((acc, mission) => {
                                                if (!acc[mission.missionType]) {
                                                    acc[mission.missionType] = { 
                                                        totalSuccess: 0, 
                                                        count: 0,
                                                        totalReward: 0
                                                    };
                                                }
                                                acc[mission.missionType].totalSuccess += mission.missionSuccess ? 1 : 0;
                                                acc[mission.missionType].totalReward += mission.reward;
                                                acc[mission.missionType].count++;
                                                return acc;
                                            }, {});
                                            
                                            return Object.entries(missionStats).map(([mission, stats]) => ({
                                                mission: mission.length > 12 ? mission.substring(0, 9) + '...' : mission,
                                                successRate: Math.round((stats.totalSuccess / stats.count) * 100),
                                                avgReward: Math.round(stats.totalReward / stats.count)
                                            }));
                                        })(),
                                        xField: 'mission',
                                        yField: 'successRate',
                                        title: 'Success Rate by Mission Type (%)',
                                        xLabel: 'Mission Type',
                                        yLabel: 'Success Rate (%)',
                                        canvasId: 'space-bar-1',
                                        color: chartUtils.colors.primary
                                    })
                                },
                                {
                                    title: "State Value Function Learning",
                                    component: React.createElement(LineChart, {
                                        data: generatedData.filter((_, index) => index % 30 === 0),
                                        xField: 'episode',
                                        yField: 'stateValue',
                                        title: 'Critic State Value Estimation Over Time',
                                        xLabel: 'Training Episode',
                                        yLabel: 'State Value Estimate',
                                        canvasId: 'space-line-3',
                                        color: chartUtils.colors.info
                                    })
                                },
                                {
                                    title: "3D Position Control Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData.filter((_, index) => index % 12 === 0),
                                        xField: 'armPositionX',
                                        yField: 'armPositionY',
                                        colorField: 'missionSuccess',
                                        title: 'Arm Position Distribution (X-Y Plane)',
                                        xLabel: 'X Position (meters)',
                                        yLabel: 'Y Position (meters)',
                                        canvasId: 'space-scatter-3'
                                    })
                                },
                                {
                                    title: "Fuel Efficiency vs Mission Complexity",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'targetMass',
                                        yField: 'fuelUsed',
                                        colorField: 'missionSuccess',
                                        title: 'Fuel Consumption by Target Object Mass',
                                        xLabel: 'Target Object Mass (kg)',
                                        yLabel: 'Fuel Used (units)',
                                        canvasId: 'space-scatter-4'
                                    })
                                }
                            ];
                            break;

                        default:
                            // Generate generic data for other examples (9-11, 13-16)
                            generatedData = dataGenerators.vineyard(100);
                            generatedCharts = [
                                {
                                    title: "Interactive Visualization Coming Soon",
                                    component: React.createElement('div', {
                                        className: 'bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-8 text-center border-2 border-dashed border-gray-300'
                                    }, [
                                        React.createElement('div', {
                                            key: 'icon',
                                            className: 'text-6xl mb-4'
                                        }, example.icon),
                                        React.createElement('h3', {
                                            key: 'title',
                                            className: 'text-xl font-semibold text-gray-700 mb-2'
                                        }, `${example.title} - Coming Soon!`),
                                        React.createElement('p', {
                                            key: 'desc',
                                            className: 'text-gray-500 mb-4'
                                        }, `Interactive ${example.algorithm} visualization is under development.`),
                                        React.createElement('div', {
                                            key: 'features',
                                            className: 'text-sm text-gray-600'
                                        }, [
                                            React.createElement('p', { key: 'p1' }, '‚úÖ Data generation complete'),
                                            React.createElement('p', { key: 'p2' }, 'üîÑ Chart implementation in progress'),
                                            React.createElement('p', { key: 'p3' }, 'üìä Explore the raw data in the Data tab!')
                                        ])
                                    ])
                                }
                            ];
                    }

                    setData(generatedData);
                    setCharts(generatedCharts);
                } catch (error) {
                    console.error('Error generating data for example:', error);
                    setData([]);
                    setCharts([]);
                }
            };

            return React.createElement(MLExamplePage, {
                title: example.title,
                description: example.description,
                algorithm: example.algorithm,
                category: example.category,
                icon: example.icon,
                data: data,
                charts: charts,
                keyPoints: example.keyPoints,
                useCases: example.useCases,
                onBack: onBack,
                exampleId: example.id
            });
        }

        // ===== RENDER APP =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MLRulesViewer));
    </script>
</body>
</html>