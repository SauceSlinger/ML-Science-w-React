<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Science Explorer - Interactive Machine Learning Guide</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-hover {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card-hover:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // ===== DATA GENERATORS =====
        const utils = {
            randomNormal: (mean = 0, std = 1) => {
                const u = Math.random();
                const v = Math.random();
                return mean + std * Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            },
            
            randomBetween: (min, max) => Math.random() * (max - min) + min,
            
            addNoise: (value, noiseLevel = 0.1) => {
                return value + utils.randomNormal(0, noiseLevel);
            }
        };

        const generateVineyardData = (samples = 200) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const rainfall = utils.randomBetween(15, 45);
                const temperature = utils.randomBetween(55, 75);
                const soilPH = utils.randomBetween(5.5, 8.0);
                
                const baseYield = 2 * rainfall + 1.5 * temperature - 3 * soilPH + 20;
                const yield_tons = Math.max(0, utils.addNoise(baseYield, 2));
                
                data.push({
                    id: i + 1,
                    rainfall: Math.round(rainfall * 10) / 10,
                    temperature: Math.round(temperature * 10) / 10,
                    soilPH: Math.round(soilPH * 100) / 100,
                    yield_tons: Math.round(yield_tons * 10) / 10,
                    year: 2015 + (i % 9)
                });
            }
            
            return data;
        };

        const generateDragonEggData = (samples = 300) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const temperature = utils.randomBetween(1000, 1400);
                const magicalAura = utils.randomBetween(0, 100);
                const incubationDays = Math.floor(utils.randomBetween(30, 120));
                
                const logit = -8 + 0.008 * temperature + 0.05 * magicalAura + 0.01 * incubationDays;
                const hatchProbability = 1 / (1 + Math.exp(-logit));
                const hatched = Math.random() < hatchProbability;
                
                data.push({
                    id: i + 1,
                    temperature: Math.round(temperature),
                    magicalAura: Math.round(magicalAura * 10) / 10,
                    incubationDays,
                    hatched,
                    eggType: ['Fire', 'Ice', 'Earth', 'Air'][Math.floor(Math.random() * 4)]
                });
            }
            
            return data;
        };

        const generateRetailCustomerData = (samples = 300) => {
            const data = [];
            const segments = [
                { name: 'Budget Buyers', avgSpend: 50, frequency: 2 },
                { name: 'Luxury Seekers', avgSpend: 300, frequency: 1 },
                { name: 'Impulse Shoppers', avgSpend: 120, frequency: 4 },
                { name: 'Regular Shoppers', avgSpend: 80, frequency: 3 },
                { name: 'Occasion Buyers', avgSpend: 200, frequency: 0.5 }
            ];
            
            for (let i = 0; i < samples; i++) {
                const segment = segments[Math.floor(Math.random() * segments.length)];
                
                const monthlySpend = Math.max(10, utils.randomNormal(segment.avgSpend, segment.avgSpend * 0.3));
                const purchaseFrequency = Math.max(0.1, utils.randomNormal(segment.frequency, segment.frequency * 0.4));
                const sessionDuration = utils.randomBetween(2, 45);
                const itemsPerPurchase = Math.max(1, Math.floor(utils.randomNormal(3, 2)));
                
                data.push({
                    id: i + 1,
                    monthlySpend: Math.round(monthlySpend),
                    purchaseFrequency: Math.round(purchaseFrequency * 10) / 10,
                    sessionDuration: Math.round(sessionDuration),
                    itemsPerPurchase,
                    segment: segment.name,
                    age: Math.floor(utils.randomBetween(18, 70)),
                    membershipYears: Math.floor(utils.randomBetween(0, 10))
                });
            }
            
            return data;
        };

        // Additional data generators for all 16 examples
        const generateStreamingData = (samples = 500) => {
            const data = [];
            const timeSlots = ['morning', 'afternoon', 'evening', 'night'];
            const devices = ['phone', 'tablet', 'laptop', 'tv'];
            const genres = ['action', 'comedy', 'drama', 'documentary', 'horror', 'romance'];
            
            for (let i = 0; i < samples; i++) {
                const timeOfDay = timeSlots[Math.floor(Math.random() * timeSlots.length)];
                const device = devices[Math.floor(Math.random() * devices.length)];
                const weekday = Math.random() > 0.3;
                const previousGenre = genres[Math.floor(Math.random() * genres.length)];
                const watchTime = Math.floor(utils.randomBetween(10, 180));
                
                let recommendedGenre;
                if (timeOfDay === 'morning' && weekday) {
                    recommendedGenre = Math.random() > 0.6 ? 'documentary' : 'comedy';
                } else if (timeOfDay === 'evening' && device === 'tv') {
                    recommendedGenre = Math.random() > 0.5 ? 'action' : 'drama';
                } else if (timeOfDay === 'night') {
                    recommendedGenre = Math.random() > 0.7 ? 'horror' : 'romance';
                } else {
                    recommendedGenre = genres[Math.floor(Math.random() * genres.length)];
                }
                
                data.push({
                    id: i + 1,
                    timeOfDay,
                    device,
                    weekday,
                    previousGenre,
                    watchTime,
                    recommendedGenre
                });
            }
            return data;
        };

        const generateInsuranceData = (samples = 400) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const claimAmount = utils.randomBetween(500, 50000);
                const policyAge = Math.floor(utils.randomBetween(1, 120));
                const claimsHistory = Math.floor(utils.randomBetween(0, 5));
                const timeToReport = Math.floor(utils.randomBetween(0, 30));
                const witnessCount = Math.floor(utils.randomBetween(0, 4));
                
                let fraudScore = 0;
                if (claimAmount > 30000) fraudScore += 0.3;
                if (timeToReport > 14) fraudScore += 0.2;
                if (claimsHistory >= 3) fraudScore += 0.25;
                if (witnessCount === 0) fraudScore += 0.15;
                if (policyAge < 6) fraudScore += 0.1;
                
                const isFraud = fraudScore > 0.5 && Math.random() > 0.3;
                
                data.push({
                    id: i + 1,
                    claimAmount: Math.round(claimAmount),
                    policyAge,
                    claimsHistory,
                    timeToReport,
                    witnessCount,
                    isFraud,
                    fraudScore: Math.round(fraudScore * 100) / 100
                });
            }
            return data;
        };

        const generateAsteroidData = (samples = 150) => {
            const data = [];
            const asteroidTypes = ['metallic', 'rocky', 'icy'];
            
            for (let i = 0; i < samples; i++) {
                const asteroidType = asteroidTypes[Math.floor(Math.random() * asteroidTypes.length)];
                
                let feature1, feature2, feature3, feature4;
                
                if (asteroidType === 'metallic') {
                    feature1 = utils.randomNormal(0.8, 0.1);
                    feature2 = utils.randomNormal(0.3, 0.05);
                    feature3 = utils.randomNormal(0.9, 0.08);
                    feature4 = utils.randomNormal(0.2, 0.03);
                } else if (asteroidType === 'rocky') {
                    feature1 = utils.randomNormal(0.4, 0.08);
                    feature2 = utils.randomNormal(0.7, 0.1);
                    feature3 = utils.randomNormal(0.3, 0.06);
                    feature4 = utils.randomNormal(0.1, 0.02);
                } else {
                    feature1 = utils.randomNormal(0.2, 0.05);
                    feature2 = utils.randomNormal(0.5, 0.08);
                    feature3 = utils.randomNormal(0.1, 0.03);
                    feature4 = utils.randomNormal(0.8, 0.1);
                }
                
                data.push({
                    id: i + 1,
                    asteroidType,
                    spectralFeature1: Math.max(0, Math.min(1, feature1)),
                    spectralFeature2: Math.max(0, Math.min(1, feature2)),
                    spectralFeature3: Math.max(0, Math.min(1, feature3)),
                    spectralFeature4: Math.max(0, Math.min(1, feature4)),
                    distance: utils.randomBetween(1, 100),
                    diameter: utils.randomBetween(10, 1000)
                });
            }
            return data;
        };

        const generateMedicalImageData = (samples = 250) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const hasTumor = Math.random() > 0.7;
                
                const brightness = utils.randomNormal(hasTumor ? 0.3 : 0.5, 0.1);
                const contrast = utils.randomNormal(hasTumor ? 0.7 : 0.4, 0.1);
                const edgeSharpness = utils.randomNormal(hasTumor ? 0.8 : 0.3, 0.08);
                const asymmetry = utils.randomNormal(hasTumor ? 0.6 : 0.2, 0.1);
                
                const confidence = hasTumor ? 
                    utils.randomBetween(0.7, 0.95) : 
                    utils.randomBetween(0.1, 0.4);
                
                data.push({
                    id: i + 1,
                    patientAge: Math.floor(utils.randomBetween(25, 85)),
                    brightness: Math.max(0, Math.min(1, brightness)),
                    contrast: Math.max(0, Math.min(1, contrast)),
                    edgeSharpness: Math.max(0, Math.min(1, edgeSharpness)),
                    asymmetry: Math.max(0, Math.min(1, asymmetry)),
                    hasTumor,
                    confidence: Math.round(confidence * 100) / 100,
                    imageType: ['xray', 'mri', 'ct'][Math.floor(Math.random() * 3)]
                });
            }
            return data;
        };

        const generateEvolutionaryData = (samples = 50) => {
            const species = [
                'Human', 'Chimpanzee', 'Gorilla', 'Orangutan', 'Gibbon',
                'Dog', 'Wolf', 'Fox', 'Cat', 'Lion', 'Tiger',
                'Mouse', 'Rat', 'Rabbit', 'Cow', 'Horse', 'Pig',
                'Chicken', 'Duck', 'Eagle', 'Salmon', 'Tuna', 'Shark'
            ];
            
            const data = [];
            
            for (let i = 0; i < Math.min(samples, species.length); i++) {
                const dnaSequence1 = utils.randomBetween(0, 1);
                const dnaSequence2 = utils.randomBetween(0, 1);
                const dnaSequence3 = utils.randomBetween(0, 1);
                const dnaSequence4 = utils.randomBetween(0, 1);
                const dnaSequence5 = utils.randomBetween(0, 1);
                
                data.push({
                    id: i + 1,
                    species: species[i],
                    dnaSequence1: Math.round(dnaSequence1 * 1000) / 1000,
                    dnaSequence2: Math.round(dnaSequence2 * 1000) / 1000,
                    dnaSequence3: Math.round(dnaSequence3 * 1000) / 1000,
                    dnaSequence4: Math.round(dnaSequence4 * 1000) / 1000,
                    dnaSequence5: Math.round(dnaSequence5 * 1000) / 1000,
                    category: i < 5 ? 'Primates' : 
                             i < 11 ? 'Carnivores' : 
                             i < 17 ? 'Herbivores' : 
                             i < 20 ? 'Birds' : 'Fish'
                });
            }
            return data;
        };

        const generateWarehouseData = (samples = 100) => {
            const data = [];
            
            for (let i = 0; i < samples; i++) {
                const startX = Math.floor(utils.randomBetween(0, 10));
                const startY = Math.floor(utils.randomBetween(0, 10));
                const goalX = Math.floor(utils.randomBetween(0, 10));
                const goalY = Math.floor(utils.randomBetween(0, 10));
                
                const optimalSteps = Math.abs(goalX - startX) + Math.abs(goalY - startY);
                const actualSteps = optimalSteps + Math.floor(utils.randomBetween(0, 5));
                const reward = 100 - (actualSteps - optimalSteps) * 10;
                
                data.push({
                    id: i + 1,
                    startX,
                    startY,
                    goalX,
                    goalY,
                    optimalSteps,
                    actualSteps,
                    reward,
                    obstacles: Math.floor(utils.randomBetween(0, 8)),
                    completionTime: Math.round((actualSteps * 2 + utils.randomBetween(0, 10)) * 10) / 10
                });
            }
            return data;
        };

        const dataGenerators = {
            vineyard: generateVineyardData,
            dragonEgg: generateDragonEggData,
            retail: generateRetailCustomerData,
            streaming: generateStreamingData,
            insurance: generateInsuranceData,
            asteroid: generateAsteroidData,
            medical: generateMedicalImageData,
            evolutionary: generateEvolutionaryData,
            warehouse: generateWarehouseData
        };

        // ===== CHART COMPONENTS =====
        const chartUtils = {
            colors: {
                primary: '#667eea',
                secondary: '#764ba2',
                success: '#10b981',
                warning: '#f59e0b',
                danger: '#ef4444',
                info: '#3b82f6',
                purple: '#8b5cf6',
                pink: '#ec4899',
                teal: '#14b8a6',
                orange: '#f97316'
            },
            
            generateColorPalette: (count) => {
                const colors = Object.values(chartUtils.colors);
                return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
            },
            
            addAlpha: (color, alpha = 0.2) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                return color;
            }
        };

        function ScatterPlot({ data, xField, yField, colorField, title, xLabel, yLabel, canvasId }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const datasets = [];
                
                if (colorField) {
                    const groups = {};
                    data.forEach(point => {
                        const group = point[colorField];
                        if (!groups[group]) groups[group] = [];
                        groups[group].push(point);
                    });
                    
                    const colors = chartUtils.generateColorPalette(Object.keys(groups).length);
                    
                    Object.keys(groups).forEach((group, index) => {
                        datasets.push({
                            label: group,
                            data: groups[group].map(point => ({
                                x: point[xField],
                                y: point[yField]
                            })),
                            backgroundColor: chartUtils.addAlpha(colors[index], 0.6),
                            borderColor: colors[index],
                            borderWidth: 1
                        });
                    });
                } else {
                    datasets.push({
                        label: 'Data Points',
                        data: data.map(point => ({
                            x: point[xField],
                            y: point[yField]
                        })),
                        backgroundColor: chartUtils.addAlpha(chartUtils.colors.primary, 0.6),
                        borderColor: chartUtils.colors.primary,
                        borderWidth: 1
                    });
                }
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: {
                                display: !!colorField
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: yLabel
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (window[`chart_${canvasId}`]) {
                        window[`chart_${canvasId}`].destroy();
                    }
                };
            }, [data, xField, yField, colorField, title, xLabel, yLabel, canvasId]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        function BarChart({ data, xField, yField, title, xLabel, yLabel, canvasId, color = chartUtils.colors.primary }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const labels = data.map(item => item[xField]);
                const values = data.map(item => item[yField]);
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [{
                            label: yLabel,
                            data: values,
                            backgroundColor: chartUtils.addAlpha(color, 0.6),
                            borderColor: color,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yLabel
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }, [data, xField, yField, title, xLabel, yLabel, canvasId, color]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        function LineChart({ data, xField, yField, title, xLabel, yLabel, canvasId, color = chartUtils.colors.info }) {
            React.useEffect(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                if (window[`chart_${canvasId}`]) {
                    window[`chart_${canvasId}`].destroy();
                }
                
                const labels = data.map(item => item[xField]);
                const values = data.map(item => item[yField]);
                
                window[`chart_${canvasId}`] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [{
                            label: yLabel,
                            data: values,
                            backgroundColor: chartUtils.addAlpha(color, 0.1),
                            borderColor: color,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: title,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yLabel
                                }
                            }
                        }
                    }
                });
            }, [data, xField, yField, title, xLabel, yLabel, canvasId, color]);
            
            return React.createElement('div', { 
                className: 'relative h-80 w-full'
            }, React.createElement('canvas', { 
                id: canvasId,
                className: 'w-full h-full'
            }));
        }

        // ===== ML EXAMPLE PAGE TEMPLATE =====
        function MLExamplePage({ 
            title, 
            description, 
            algorithm, 
            category,
            icon,
            data, 
            charts, 
            keyPoints, 
            useCases,
            onBack 
        }) {
            const [selectedTab, setSelectedTab] = React.useState('overview');
            const [dataPageSize, setDataPageSize] = React.useState(20);
            const [currentDataPage, setCurrentDataPage] = React.useState(0);
            
            const getCategoryColor = (category) => {
                switch (category) {
                    case 'Supervised':
                        return {
                            bg: 'bg-blue-100',
                            border: 'border-blue-500',
                            text: 'text-blue-700',
                            badge: 'bg-blue-500'
                        };
                    case 'Unsupervised':
                        return {
                            bg: 'bg-green-100',
                            border: 'border-green-500',
                            text: 'text-green-700',
                            badge: 'bg-green-500'
                        };
                    case 'RL':
                        return {
                            bg: 'bg-purple-100',
                            border: 'border-purple-500',
                            text: 'text-purple-700',
                            badge: 'bg-purple-500'
                        };
                    default:
                        return {
                            bg: 'bg-gray-100',
                            border: 'border-gray-500',
                            text: 'text-gray-700',
                            badge: 'bg-gray-500'
                        };
                }
            };
            
            const colors = getCategoryColor(category);
            
            const startIndex = currentDataPage * dataPageSize;
            const endIndex = startIndex + dataPageSize;
            const paginatedData = data.slice(startIndex, endIndex);
            const totalPages = Math.ceil(data.length / dataPageSize);
            
            const tabs = [
                { id: 'overview', label: 'Overview', icon: 'üìä' },
                { id: 'data', label: 'Data', icon: 'üíæ' },
                { id: 'visualization', label: 'Visualization', icon: 'üìà' },
                { id: 'insights', label: 'Insights', icon: 'üí°' }
            ];
            
            const renderOverview = () => React.createElement('div', { 
                className: 'space-y-6'
            }, [
                React.createElement('div', {
                    key: 'algo-info',
                    className: `${colors.bg} rounded-lg p-6 border-l-4 ${colors.border}`
                }, [
                    React.createElement('div', {
                        key: 'header',
                        className: 'flex items-center gap-3 mb-4'
                    }, [
                        React.createElement('span', { key: 'icon', className: 'text-4xl' }, icon),
                        React.createElement('div', { key: 'title-section' }, [
                            React.createElement('h2', {
                                key: 'title',
                                className: `text-2xl font-bold ${colors.text}`
                            }, title),
                            React.createElement('span', {
                                key: 'badge',
                                className: `${colors.badge} text-white text-sm font-bold px-3 py-1 rounded-full`
                            }, `${category} Learning`)
                        ])
                    ]),
                    React.createElement('p', {
                        key: 'description',
                        className: 'text-gray-700 text-lg leading-relaxed'
                    }, description)
                ]),
                
                React.createElement('div', {
                    key: 'key-points',
                    className: 'bg-white rounded-lg p-6 shadow-md'
                }, [
                    React.createElement('h3', {
                        key: 'kp-title',
                        className: 'text-xl font-semibold mb-4 flex items-center gap-2'
                    }, ['‚ú® Key Points']),
                    React.createElement('ul', {
                        key: 'kp-list',
                        className: 'space-y-3'
                    }, keyPoints.map((point, index) => 
                        React.createElement('li', {
                            key: index,
                            className: 'flex items-start gap-3'
                        }, [
                            React.createElement('span', {
                                key: 'bullet',
                                className: `${colors.text} font-bold`
                            }, '‚Ä¢'),
                            React.createElement('span', {
                                key: 'text',
                                className: 'text-gray-700'
                            }, point)
                        ])
                    ))
                ])
            ]);
            
            const renderDataTable = () => {
                if (!data || data.length === 0) {
                    return React.createElement('div', {
                        className: 'text-center py-8 text-gray-500'
                    }, 'No data available');
                }
                
                const columns = Object.keys(data[0]);
                
                return React.createElement('div', {
                    className: 'bg-white rounded-lg shadow-md overflow-hidden'
                }, [
                    React.createElement('div', {
                        key: 'header',
                        className: 'px-6 py-4 bg-gray-50 border-b'
                    }, [
                        React.createElement('h3', {
                            key: 'title',
                            className: 'text-lg font-semibold'
                        }, 'üíæ Raw Data'),
                        React.createElement('p', {
                            key: 'info',
                            className: 'text-sm text-gray-600 mt-1'
                        }, `Showing ${startIndex + 1}-${Math.min(endIndex, data.length)} of ${data.length} records`)
                    ]),
                    
                    React.createElement('div', {
                        key: 'table-container',
                        className: 'overflow-x-auto'
                    }, 
                        React.createElement('table', {
                            className: 'w-full'
                        }, [
                            React.createElement('thead', {
                                key: 'thead',
                                className: 'bg-gray-100'
                            }, 
                                React.createElement('tr', {}, 
                                    columns.map(column => 
                                        React.createElement('th', {
                                            key: column,
                                            className: 'px-4 py-3 text-left text-sm font-medium text-gray-700'
                                        }, column)
                                    )
                                )
                            ),
                            React.createElement('tbody', {
                                key: 'tbody',
                                className: 'divide-y divide-gray-200'
                            }, 
                                paginatedData.map((row, index) => 
                                    React.createElement('tr', {
                                        key: index,
                                        className: 'hover:bg-gray-50'
                                    }, 
                                        columns.map(column => 
                                            React.createElement('td', {
                                                key: column,
                                                className: 'px-4 py-3 text-sm text-gray-900'
                                            }, 
                                                typeof row[column] === 'boolean' ? 
                                                    (row[column] ? '‚úÖ' : '‚ùå') :
                                                    typeof row[column] === 'number' ? 
                                                        row[column].toFixed(2) :
                                                        String(row[column])
                                            )
                                        )
                                    )
                                )
                            )
                        ])
                    )
                ]);
            };
            
            const renderVisualization = () => React.createElement('div', {
                className: 'space-y-6'
            }, [
                React.createElement('div', {
                    key: 'viz-header',
                    className: 'bg-white rounded-lg p-6 shadow-md'
                }, [
                    React.createElement('h3', {
                        key: 'title',
                        className: 'text-xl font-semibold mb-2'
                    }, 'üìà Interactive Visualizations'),
                    React.createElement('p', {
                        key: 'desc',
                        className: 'text-gray-600'
                    }, 'Explore the data through various chart types and identify patterns.')
                ]),
                
                ...charts.map((chart, index) => 
                    React.createElement('div', {
                        key: index,
                        className: 'bg-white rounded-lg p-6 shadow-md'
                    }, [
                        React.createElement('h4', {
                            key: 'chart-title',
                            className: 'text-lg font-medium mb-4 text-gray-800'
                        }, chart.title),
                        chart.component
                    ])
                )
            ]);
            
            const renderInsights = () => React.createElement('div', {
                className: 'space-y-6'
            }, [
                React.createElement('div', {
                    key: 'algo-insights',
                    className: 'bg-white rounded-lg p-6 shadow-md'
                }, [
                    React.createElement('h3', {
                        key: 'title',
                        className: 'text-xl font-semibold mb-4 flex items-center gap-2'
                    }, ['üß† Algorithm Insights']),
                    React.createElement('div', {
                        key: 'content',
                        className: 'prose max-w-none text-gray-700'
                    }, [
                        React.createElement('p', {
                            key: 'p1'
                        }, `This ${algorithm} model demonstrates ${category.toLowerCase()} learning principles by analyzing the provided dataset.`),
                        React.createElement('p', {
                            key: 'p2'
                        }, `The visualization reveals patterns and relationships that the algorithm uses to make predictions or discoveries.`),
                        React.createElement('p', {
                            key: 'p3'
                        }, 'Observe how different features contribute to the model\'s decision-making process through the interactive charts.')
                    ])
                ])
            ]);
            
            const renderTabContent = () => {
                switch (selectedTab) {
                    case 'overview': return renderOverview();
                    case 'data': return renderDataTable();
                    case 'visualization': return renderVisualization();
                    case 'insights': return renderInsights();
                    default: return renderOverview();
                }
            };
            
            return React.createElement('div', {
                className: 'min-h-screen bg-gray-50'
            }, [
                React.createElement('header', {
                    key: 'header',
                    className: 'bg-white shadow-sm border-b'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-4'
                    }, 
                        React.createElement('div', {
                            className: 'flex items-center gap-4'
                        }, [
                            React.createElement('button', {
                                key: 'back-btn',
                                onClick: onBack,
                                className: 'flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors'
                            }, ['‚Üê Back to Examples']),
                            
                            React.createElement('div', {
                                key: 'title-section',
                                className: 'flex items-center gap-3'
                            }, [
                                React.createElement('span', {
                                    key: 'icon',
                                    className: 'text-3xl'
                                }, icon),
                                React.createElement('h1', {
                                    key: 'title',
                                    className: 'text-2xl font-bold text-gray-800'
                                }, title)
                            ])
                        ])
                    )
                ),
                
                React.createElement('nav', {
                    key: 'nav',
                    className: 'bg-white shadow-sm'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4'
                    }, 
                        React.createElement('div', {
                            className: 'flex space-x-8'
                        }, 
                            tabs.map(tab => 
                                React.createElement('button', {
                                    key: tab.id,
                                    onClick: () => setSelectedTab(tab.id),
                                    className: `flex items-center gap-2 px-3 py-4 border-b-2 font-medium text-sm transition-colors ${
                                        selectedTab === tab.id ? 
                                            `${colors.border.replace('border-', 'border-b-')} ${colors.text}` : 
                                            'border-transparent text-gray-500 hover:text-gray-700'
                                    }`
                                }, [`${tab.icon} ${tab.label}`])
                            )
                        )
                    )
                ),
                
                React.createElement('main', {
                    key: 'main',
                    className: 'container mx-auto px-4 py-8'
                }, renderTabContent())
            ]);
        }

        // ===== ML MODULES CONTENT DATA =====
        const mlModulesContent = [
            // Supervised Learning
            {
                id: 1,
                category: "Supervised",
                title: "Vineyard Yield Predictor",
                description: "A wine estate in Napa Valley uses linear regression to forecast annual grape harvest based on rainfall, temperature, and soil pH levels.",
                algorithm: "Linear Regression",
                useCases: ["Predicting tons of grapes per acre", "Optimizing irrigation schedules", "Planning production capacity"],
                keyPoints: [
                    "Simple and interpretable model",
                    "Works well with continuous variables",
                    "Weather data most influential factor"
                ],
                icon: "üçá"
            },
            {
                id: 2,
                category: "Supervised",
                title: "Dragon Egg Hatching Classifier",
                description: "In a fantasy realm, dragon breeders use logistic regression to predict if an egg will hatch based on incubation temperature and magical aura readings.",
                algorithm: "Logistic Regression",
                useCases: ["Determining viable eggs (hatch/no-hatch)", "Optimizing incubation conditions", "Resource allocation for care"],
                keyPoints: [
                    "Binary outcome prediction",
                    "Probability-based decisions",
                    "Temperature threshold at 1,200¬∞F critical"
                ],
                icon: "üêâ"
            },
            {
                id: 3,
                category: "Supervised",
                title: "Streaming Content Recommender",
                description: "A major streaming platform uses decision trees to determine which genres to recommend based on viewing history, time of day, and device type.",
                algorithm: "Decision Tree",
                useCases: ["Genre selection for users", "Personalized homepage layouts", "Weekend vs weekday content"],
                keyPoints: [
                    "Easy to explain to stakeholders",
                    "Handles categorical features well",
                    "Visualizable decision paths"
                ],
                icon: "üì∫"
            },
            {
                id: 4,
                category: "Supervised",
                title: "Insurance Fraud Detector",
                description: "An insurance company deploys random forest to identify fraudulent claims by analyzing claim patterns, policy history, and timing anomalies.",
                algorithm: "Random Forest",
                useCases: ["Flagging suspicious claims for investigation", "Prioritizing auditor workload", "Reducing false positives"],
                keyPoints: [
                    "Ensemble reduces false alarms",
                    "Handles imbalanced datasets",
                    "Identifies top fraud indicators"
                ],
                icon: "üîê"
            },
            {
                id: 5,
                category: "Supervised",
                title: "Asteroid Composition Analyzer",
                description: "NASA uses SVM to classify asteroid types (metallic, rocky, icy) from spectral signature data captured by space telescopes.",
                algorithm: "Support Vector Machine",
                useCases: ["Mining target identification", "Collision risk assessment", "Scientific research prioritization"],
                keyPoints: [
                    "Handles high-dimensional spectral data",
                    "Works with limited training samples",
                    "Kernel trick for non-linear boundaries"
                ],
                icon: "‚òÑÔ∏è"
            },
            {
                id: 6,
                category: "Supervised",
                title: "Medical Image Diagnosis System",
                description: "A hospital network employs neural networks to detect early-stage tumors in X-rays and MRI scans with radiologist-level accuracy.",
                algorithm: "Neural Network",
                useCases: ["Cancer screening automation", "Reducing diagnostic wait times", "Second-opinion validation"],
                keyPoints: [
                    "Learns complex visual patterns",
                    "Trained on millions of images",
                    "GPU-accelerated processing"
                ],
                icon: "üè•"
            },
            
            // Unsupervised Learning
            {
                id: 7,
                category: "Unsupervised",
                title: "Retail Customer Segmentation",
                description: "A global retailer uses K-Means to group shoppers into personas (budget buyers, luxury seekers, impulse shoppers) based on purchase behavior.",
                algorithm: "K-Means Clustering",
                useCases: ["Targeted marketing campaigns", "Store layout optimization", "Inventory planning by segment"],
                keyPoints: [
                    "Discovered 5 distinct customer types",
                    "Updated quarterly for seasonality",
                    "Drives 23% increase in conversion"
                ],
                icon: "üõçÔ∏è"
            },
            {
                id: 8,
                category: "Unsupervised",
                title: "Evolutionary Tree Constructor",
                description: "Biologists use hierarchical clustering to build phylogenetic trees showing evolutionary relationships between species based on DNA sequences.",
                algorithm: "Hierarchical Clustering",
                useCases: ["Species classification", "Tracing evolutionary pathways", "Identifying common ancestors"],
                keyPoints: [
                    "Creates natural hierarchy",
                    "No preset cluster count needed",
                    "Dendrogram shows relationships"
                ],
                icon: "üß¨"
            },
            {
                id: 9,
                category: "Unsupervised",
                title: "AI Art Style Compressor",
                description: "A digital art platform uses PCA to reduce thousands of style attributes into 10 principal components for efficient similarity matching.",
                algorithm: "Principal Component Analysis",
                useCases: ["Fast style-based search", "Artwork recommendation", "Trend analysis visualization"],
                keyPoints: [
                    "Reduces 2,048 features to 10",
                    "Retains 95% of style variance",
                    "Enables real-time comparisons"
                ],
                icon: "üé®"
            },
            {
                id: 10,
                category: "Unsupervised",
                title: "Urban Crime Hotspot Mapper",
                description: "City police use DBSCAN to identify crime clusters and patrol zones from incident GPS coordinates, ignoring isolated events.",
                algorithm: "DBSCAN",
                useCases: ["Patrol route optimization", "Resource deployment planning", "Crime prevention strategies"],
                keyPoints: [
                    "Finds irregular-shaped hotspots",
                    "Filters random incidents as noise",
                    "Adapts to city geography"
                ],
                icon: "üöî"
            },
            {
                id: 11,
                category: "Unsupervised",
                title: "Quantum Data Denoiser",
                description: "In a sci-fi research lab, autoencoders clean quantum sensor readings by learning to reconstruct signals while filtering measurement noise.",
                algorithm: "Autoencoder",
                useCases: ["Signal purification", "Anomaly detection in experiments", "Data compression for transmission"],
                keyPoints: [
                    "Learns normal signal patterns",
                    "Unsupervised noise removal",
                    "Compresses to 15% original size"
                ],
                icon: "‚öõÔ∏è"
            },
            
            // Reinforcement Learning
            {
                id: 12,
                category: "RL",
                title: "Warehouse Robot Navigator",
                description: "An e-commerce fulfillment center trains robots with Q-Learning to find optimal paths through dynamic warehouse layouts.",
                algorithm: "Q-Learning",
                useCases: ["Fastest picking routes", "Collision avoidance", "Adapting to layout changes"],
                keyPoints: [
                    "Learns from trial and error",
                    "Handles moving obstacles",
                    "Reduced picking time by 40%"
                ],
                icon: "ü§ñ"
            },
            {
                id: 13,
                category: "RL",
                title: "Virtual Racing Champion",
                description: "A game studio uses DQN to create unbeatable AI opponents that learn racing lines and overtaking strategies from millions of gameplay sessions.",
                algorithm: "Deep Q-Network",
                useCases: ["Adaptive difficulty scaling", "Player training mode", "Tournament-level AI"],
                keyPoints: [
                    "Masters complex 3D environments",
                    "Learns from visual input only",
                    "Beats 98% of human players"
                ],
                icon: "üèéÔ∏è"
            },
            {
                id: 14,
                category: "RL",
                title: "Renewable Energy Grid Optimizer",
                description: "A smart grid uses Policy Gradient to balance solar/wind power distribution, learning to minimize costs while meeting real-time demand.",
                algorithm: "Policy Gradient",
                useCases: ["Peak load management", "Battery storage optimization", "Carbon footprint reduction"],
                keyPoints: [
                    "Continuous action space (0-100% allocation)",
                    "Adapts to weather patterns",
                    "Saves $2M annually in costs"
                ],
                icon: "‚ö°"
            },
            {
                id: 15,
                category: "RL",
                title: "Space Station Arm Controller",
                description: "ISS robotic arms use Actor-Critic to perform delicate satellite repairs, learning precise movements in zero-gravity microgravity conditions.",
                algorithm: "Actor-Critic",
                useCases: ["Satellite capture and repair", "Cargo module docking", "External maintenance tasks"],
                keyPoints: [
                    "Sub-millimeter precision required",
                    "Stable learning in simulations",
                    "Transferred to real hardware"
                ],
                icon: "üõ∞Ô∏è"
            },
            {
                id: 16,
                category: "RL",
                title: "Clinical Trial Dose Finder",
                description: "Pharmaceutical researchers use Multi-Armed Bandit to dynamically adjust drug dosages across patient groups, maximizing efficacy while minimizing side effects.",
                algorithm: "Multi-Armed Bandit",
                useCases: ["Adaptive dosing protocols", "Patient safety optimization", "Accelerated trial completion"],
                keyPoints: [
                    "Balances exploration vs exploitation",
                    "Ethical early stopping criteria",
                    "Reduced trial time by 6 months"
                ],
                icon: "üíä"
            }
        ];

        // ===== MAIN APP COMPONENT =====
        function MLRulesViewer() {
            const [selectedCategory, setSelectedCategory] = useState('All');
            const [searchTerm, setSearchTerm] = useState('');
            const [expandedCard, setExpandedCard] = useState(null);
            const [currentView, setCurrentView] = useState('home');
            const [selectedExample, setSelectedExample] = useState(null);

            const categories = ['All', 'Supervised', 'Unsupervised', 'RL'];

            const getCategoryColor = (category) => {
                switch (category) {
                    case 'Supervised':
                        return {
                            bg: 'bg-blue-100',
                            border: 'border-blue-500',
                            text: 'text-blue-700',
                            badge: 'bg-blue-500',
                            hover: 'hover:bg-blue-50'
                        };
                    case 'Unsupervised':
                        return {
                            bg: 'bg-green-100',
                            border: 'border-green-500',
                            text: 'text-green-700',
                            badge: 'bg-green-500',
                            hover: 'hover:bg-green-50'
                        };
                    case 'RL':
                        return {
                            bg: 'bg-purple-100',
                            border: 'border-purple-500',
                            text: 'text-purple-700',
                            badge: 'bg-purple-500',
                            hover: 'hover:bg-purple-50'
                        };
                    default:
                        return {
                            bg: 'bg-gray-100',
                            border: 'border-gray-500',
                            text: 'text-gray-700',
                            badge: 'bg-gray-500',
                            hover: 'hover:bg-gray-50'
                        };
                }
            };

            const filteredModules = mlModulesContent.filter(module => {
                const matchesCategory = selectedCategory === 'All' || module.category === selectedCategory;
                const matchesSearch = module.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                    module.description.toLowerCase().includes(searchTerm.toLowerCase());
                return matchesCategory && matchesSearch;
            });

            const getCategoryStats = () => {
                const supervised = mlModulesContent.filter(m => m.category === 'Supervised').length;
                const unsupervised = mlModulesContent.filter(m => m.category === 'Unsupervised').length;
                const rl = mlModulesContent.filter(m => m.category === 'RL').length;
                return { supervised, unsupervised, rl };
            };

            const stats = getCategoryStats();

            const handleExampleClick = (example) => {
                setSelectedExample(example);
                setCurrentView('example');
            };

            const handleBackToHome = () => {
                setCurrentView('home');
                setSelectedExample(null);
            };

            if (currentView === 'example' && selectedExample) {
                return React.createElement(MLExamplePageWrapper, {
                    example: selectedExample,
                    onBack: handleBackToHome
                });
            }

            return React.createElement('div', {
                className: 'min-h-screen bg-gray-50'
            }, [
                React.createElement('header', {
                    key: 'header',
                    className: 'gradient-bg text-white shadow-lg'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-8 sm:py-12'
                    }, [
                        React.createElement('h1', {
                            key: 'title',
                            className: 'text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-3'
                        }, 'ü§ñ ML Science Explorer'),
                        React.createElement('p', {
                            key: 'subtitle',
                            className: 'text-center text-sm sm:text-base md:text-lg opacity-90 max-w-2xl mx-auto'
                        }, 'Your interactive guide to Machine Learning algorithms and applications'),
                        
                        React.createElement('div', {
                            key: 'stats',
                            className: 'mt-6 grid grid-cols-3 gap-2 sm:gap-4 max-w-2xl mx-auto'
                        }, [
                            React.createElement('div', {
                                key: 'supervised',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.supervised),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Supervised')
                            ]),
                            React.createElement('div', {
                                key: 'unsupervised',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.unsupervised),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Unsupervised')
                            ]),
                            React.createElement('div', {
                                key: 'rl',
                                className: 'bg-white bg-opacity-20 rounded-lg p-3 text-center'
                            }, [
                                React.createElement('div', {
                                    key: 'count',
                                    className: 'text-xl sm:text-2xl font-bold'
                                }, stats.rl),
                                React.createElement('div', {
                                    key: 'label',
                                    className: 'text-xs sm:text-sm opacity-90'
                                }, 'Reinforcement')
                            ])
                        ])
                    ])
                ),

                React.createElement('div', {
                    key: 'controls',
                    className: 'sticky top-0 bg-white shadow-md z-10'
                }, 
                    React.createElement('div', {
                        className: 'container mx-auto px-4 py-4'
                    }, [
                        React.createElement('div', {
                            key: 'search',
                            className: 'mb-4'
                        }, 
                            React.createElement('input', {
                                type: 'text',
                                placeholder: 'üîç Search algorithms...',
                                value: searchTerm,
                                onChange: (e) => setSearchTerm(e.target.value),
                                className: 'w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none transition-colors text-sm sm:text-base'
                            })
                        ),

                        React.createElement('div', {
                            key: 'filters',
                            className: 'flex flex-wrap gap-2'
                        }, 
                            categories.map(category => {
                                const colors = getCategoryColor(category === 'All' ? 'default' : category);
                                const isActive = selectedCategory === category;
                                return React.createElement('button', {
                                    key: category,
                                    onClick: () => setSelectedCategory(category),
                                    className: `px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-semibold text-xs sm:text-sm transition-all ${
                                        isActive
                                            ? `${colors.badge} text-white shadow-md`
                                            : `${colors.bg} ${colors.text} ${colors.hover}`
                                    }`
                                }, [
                                    category,
                                    category !== 'All' && React.createElement('span', {
                                        key: 'count',
                                        className: 'ml-2 opacity-75'
                                    }, `(${category === 'Supervised' ? stats.supervised : 
                                         category === 'Unsupervised' ? stats.unsupervised : 
                                         stats.rl})`)
                                ]);
                            })
                        )
                    ])
                ),

                React.createElement('main', {
                    key: 'main',
                    className: 'container mx-auto px-4 py-8'
                }, 
                    filteredModules.length === 0 ? 
                        React.createElement('div', {
                            className: 'text-center py-12'
                        }, [
                            React.createElement('div', {
                                key: 'icon',
                                className: 'text-6xl mb-4'
                            }, 'üîç'),
                            React.createElement('h3', {
                                key: 'title',
                                className: 'text-xl sm:text-2xl font-semibold text-gray-700 mb-2'
                            }, 'No algorithms found'),
                            React.createElement('p', {
                                key: 'desc',
                                className: 'text-gray-500'
                            }, 'Try adjusting your search or filter criteria')
                        ]) :
                        React.createElement('div', {
                            className: 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6'
                        }, 
                            filteredModules.map((module, index) => {
                                const colors = getCategoryColor(module.category);
                                
                                return React.createElement('div', {
                                    key: module.id,
                                    className: `bg-white rounded-xl shadow-md border-l-4 ${colors.border} card-hover fade-in overflow-hidden cursor-pointer`,
                                    style: { animationDelay: `${index * 0.05}s` },
                                    onClick: () => handleExampleClick(module)
                                }, [
                                    React.createElement('div', {
                                        key: 'header',
                                        className: `${colors.bg} p-4`
                                    }, 
                                        React.createElement('div', {
                                            className: 'flex items-start justify-between'
                                        }, 
                                            React.createElement('div', {
                                                className: 'flex-1'
                                            }, [
                                                React.createElement('div', {
                                                    key: 'badges',
                                                    className: 'flex items-center gap-2 mb-2'
                                                }, [
                                                    React.createElement('span', {
                                                        key: 'icon',
                                                        className: 'text-3xl'
                                                    }, module.icon),
                                                    React.createElement('span', {
                                                        key: 'badge',
                                                        className: `${colors.badge} text-white text-xs font-bold px-2 py-1 rounded`
                                                    }, module.category)
                                                ]),
                                                React.createElement('h3', {
                                                    key: 'title',
                                                    className: `text-lg sm:text-xl font-bold ${colors.text}`
                                                }, module.title)
                                            ])
                                        )
                                    ),

                                    React.createElement('div', {
                                        key: 'body',
                                        className: 'p-4'
                                    }, [
                                        React.createElement('p', {
                                            key: 'description',
                                            className: 'text-gray-700 text-sm sm:text-base mb-4'
                                        }, module.description),

                                        React.createElement('div', {
                                            key: 'key-points',
                                            className: 'mb-4'
                                        }, [
                                            React.createElement('h4', {
                                                key: 'kp-title',
                                                className: 'font-semibold text-gray-900 mb-2 text-sm'
                                            }, '‚ú® Key Points:'),
                                            React.createElement('ul', {
                                                key: 'kp-list',
                                                className: 'space-y-1'
                                            }, 
                                                module.keyPoints.slice(0, 2).map((point, idx) =>
                                                    React.createElement('li', {
                                                        key: idx,
                                                        className: 'text-xs sm:text-sm text-gray-600 flex items-start'
                                                    }, [
                                                        React.createElement('span', {
                                                            key: 'bullet',
                                                            className: `${colors.text} mr-2`
                                                        }, '‚Ä¢'),
                                                        point
                                                    ])
                                                )
                                            )
                                        ]),

                                        React.createElement('div', {
                                            key: 'cta',
                                            className: 'mt-4'
                                        }, 
                                            React.createElement('button', {
                                                className: `w-full text-center font-semibold text-sm ${colors.text} ${colors.hover} p-2 rounded transition-colors flex items-center justify-center gap-2`
                                            }, [
                                                React.createElement('span', { key: 'text' }, 'üìä View Interactive Example'),
                                                React.createElement('span', { key: 'arrow' }, '‚Üí')
                                            ])
                                        )
                                    ])
                                ]);
                            })
                        )
                )
            ]);
        }

        // ===== ML EXAMPLE PAGE WRAPPER =====
        function MLExamplePageWrapper({ example, onBack }) {
            const [data, setData] = useState([]);
            const [charts, setCharts] = useState([]);

            useEffect(() => {
                generateExampleData(example);
            }, [example]);

            const generateExampleData = (example) => {
                let generatedData = [];
                let generatedCharts = [];

                try {
                    switch (example.id) {
                        case 1: // Vineyard
                            generatedData = dataGenerators.vineyard(200);
                            generatedCharts = [
                                {
                                    title: "Yield vs Rainfall Correlation",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'rainfall',
                                        yField: 'yield_tons',
                                        title: 'Vineyard Yield vs Rainfall',
                                        xLabel: 'Rainfall (inches)',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-1'
                                    })
                                },
                                {
                                    title: "Temperature Impact Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'temperature',
                                        yField: 'yield_tons',
                                        title: 'Yield vs Temperature',
                                        xLabel: 'Average Temperature (¬∞F)',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-2'
                                    })
                                },
                                {
                                    title: "Soil pH Effects",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'soilPH',
                                        yField: 'yield_tons',
                                        title: 'Yield vs Soil pH',
                                        xLabel: 'Soil pH Level',
                                        yLabel: 'Yield (tons per acre)',
                                        canvasId: 'vineyard-scatter-3'
                                    })
                                }
                            ];
                            break;

                        case 2: // Dragon Egg
                            generatedData = dataGenerators.dragonEgg(300);
                            generatedCharts = [
                                {
                                    title: "Hatching Success by Temperature",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'temperature',
                                        yField: 'magicalAura',
                                        colorField: 'hatched',
                                        title: 'Dragon Egg Hatching Patterns',
                                        xLabel: 'Temperature (¬∞F)',
                                        yLabel: 'Magical Aura',
                                        canvasId: 'dragon-scatter-1'
                                    })
                                },
                                {
                                    title: "Egg Type Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, egg) => {
                                            acc[egg.eggType] = (acc[egg.eggType] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Dragon Egg Types',
                                        canvasId: 'dragon-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 3: // Streaming
                            generatedData = dataGenerators.streaming(500);
                            generatedCharts = [
                                {
                                    title: "Genre Recommendations by Time",
                                    component: React.createElement(BarChart, {
                                        data: Object.entries(generatedData.reduce((acc, session) => {
                                            acc[session.recommendedGenre] = (acc[session.recommendedGenre] || 0) + 1;
                                            return acc;
                                        }, {})).map(([genre, count]) => ({ genre, count })),
                                        xField: 'genre',
                                        yField: 'count',
                                        title: 'Genre Recommendation Frequency',
                                        xLabel: 'Genre',
                                        yLabel: 'Recommendations',
                                        canvasId: 'streaming-bar-1'
                                    })
                                }
                            ];
                            break;

                        case 4: // Insurance
                            generatedData = dataGenerators.insurance(400);
                            generatedCharts = [
                                {
                                    title: "Fraud Detection Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'claimAmount',
                                        yField: 'timeToReport',
                                        colorField: 'isFraud',
                                        title: 'Claim Amount vs Reporting Time',
                                        xLabel: 'Claim Amount ($)',
                                        yLabel: 'Days to Report',
                                        canvasId: 'insurance-scatter-1'
                                    })
                                },
                                {
                                    title: "Fraud vs Legitimate Claims",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, claim) => {
                                            const type = claim.isFraud ? 'Fraudulent' : 'Legitimate';
                                            acc[type] = (acc[type] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Claim Types Distribution',
                                        canvasId: 'insurance-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 5: // Asteroid
                            generatedData = dataGenerators.asteroid(150);
                            generatedCharts = [
                                {
                                    title: "Spectral Feature Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'spectralFeature1',
                                        yField: 'spectralFeature2',
                                        colorField: 'asteroidType',
                                        title: 'Spectral Features Classification',
                                        xLabel: 'Reflectance Feature',
                                        yLabel: 'Absorption Feature',
                                        canvasId: 'asteroid-scatter-1'
                                    })
                                },
                                {
                                    title: "Asteroid Type Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, asteroid) => {
                                            acc[asteroid.asteroidType] = (acc[asteroid.asteroidType] || 0) + 1;
                                            return acc;
                                        }, {})).map(([type, count]) => ({ type, count })),
                                        labelField: 'type',
                                        valueField: 'count',
                                        title: 'Asteroid Types',
                                        canvasId: 'asteroid-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 6: // Medical
                            generatedData = dataGenerators.medical(250);
                            generatedCharts = [
                                {
                                    title: "Image Feature Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'brightness',
                                        yField: 'contrast',
                                        colorField: 'hasTumor',
                                        title: 'Brightness vs Contrast Analysis',
                                        xLabel: 'Image Brightness',
                                        yLabel: 'Image Contrast',
                                        canvasId: 'medical-scatter-1'
                                    })
                                },
                                {
                                    title: "Diagnostic Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, scan) => {
                                            const diagnosis = scan.hasTumor ? 'Tumor Detected' : 'Clear';
                                            acc[diagnosis] = (acc[diagnosis] || 0) + 1;
                                            return acc;
                                        }, {})).map(([diagnosis, count]) => ({ diagnosis, count })),
                                        labelField: 'diagnosis',
                                        valueField: 'count',
                                        title: 'Medical Diagnoses',
                                        canvasId: 'medical-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 7: // Retail Customer Segmentation
                            generatedData = dataGenerators.retail(300);
                            const segmentCounts = generatedData.reduce((acc, customer) => {
                                acc[customer.segment] = (acc[customer.segment] || 0) + 1;
                                return acc;
                            }, {});
                            
                            const segmentData = Object.entries(segmentCounts).map(([segment, count]) => ({
                                segment,
                                count
                            }));

                            generatedCharts = [
                                {
                                    title: "Customer Segment Distribution",
                                    component: React.createElement(PieChart, {
                                        data: segmentData,
                                        labelField: 'segment',
                                        valueField: 'count',
                                        title: 'Customer Segments',
                                        canvasId: 'retail-pie-1'
                                    })
                                },
                                {
                                    title: "Spending vs Purchase Frequency",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'monthlySpend',
                                        yField: 'purchaseFrequency',
                                        colorField: 'segment',
                                        title: 'Customer Behavior Patterns',
                                        xLabel: 'Monthly Spend ($)',
                                        yLabel: 'Purchase Frequency',
                                        canvasId: 'retail-scatter-1'
                                    })
                                }
                            ];
                            break;

                        case 8: // Evolutionary Tree
                            generatedData = dataGenerators.evolutionary(25);
                            generatedCharts = [
                                {
                                    title: "Species DNA Similarity",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'dnaSequence1',
                                        yField: 'dnaSequence2',
                                        colorField: 'category',
                                        title: 'DNA Sequence Analysis',
                                        xLabel: 'DNA Sequence 1',
                                        yLabel: 'DNA Sequence 2',
                                        canvasId: 'evolution-scatter-1'
                                    })
                                },
                                {
                                    title: "Species Category Distribution",
                                    component: React.createElement(PieChart, {
                                        data: Object.entries(generatedData.reduce((acc, species) => {
                                            acc[species.category] = (acc[species.category] || 0) + 1;
                                            return acc;
                                        }, {})).map(([category, count]) => ({ category, count })),
                                        labelField: 'category',
                                        valueField: 'count',
                                        title: 'Species Categories',
                                        canvasId: 'evolution-pie-1'
                                    })
                                }
                            ];
                            break;

                        case 12: // Warehouse Robot
                            generatedData = dataGenerators.warehouse(100);
                            generatedCharts = [
                                {
                                    title: "Robot Performance Analysis",
                                    component: React.createElement(ScatterPlot, {
                                        data: generatedData,
                                        xField: 'optimalSteps',
                                        yField: 'actualSteps',
                                        title: 'Optimal vs Actual Steps',
                                        xLabel: 'Optimal Steps',
                                        yLabel: 'Actual Steps',
                                        canvasId: 'warehouse-scatter-1'
                                    })
                                },
                                {
                                    title: "Mission Rewards Distribution",
                                    component: React.createElement(BarChart, {
                                        data: generatedData.map(d => ({ 
                                            rewardRange: d.reward >= 90 ? '90-100' : 
                                                        d.reward >= 80 ? '80-89' : 
                                                        d.reward >= 70 ? '70-79' : 
                                                        d.reward >= 60 ? '60-69' : 'Below 60',
                                            count: 1 
                                        })).reduce((acc, curr) => {
                                            const existing = acc.find(item => item.rewardRange === curr.rewardRange);
                                            if (existing) existing.count++;
                                            else acc.push(curr);
                                            return acc;
                                        }, []),
                                        xField: 'rewardRange',
                                        yField: 'count',
                                        title: 'Reward Score Distribution',
                                        xLabel: 'Reward Range',
                                        yLabel: 'Number of Missions',
                                        canvasId: 'warehouse-bar-1'
                                    })
                                }
                            ];
                            break;

                        default:
                            // Generate generic data for other examples (9-11, 13-16)
                            generatedData = dataGenerators.vineyard(100);
                            generatedCharts = [
                                {
                                    title: "Interactive Visualization Coming Soon",
                                    component: React.createElement('div', {
                                        className: 'bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-8 text-center border-2 border-dashed border-gray-300'
                                    }, [
                                        React.createElement('div', {
                                            key: 'icon',
                                            className: 'text-6xl mb-4'
                                        }, example.icon),
                                        React.createElement('h3', {
                                            key: 'title',
                                            className: 'text-xl font-semibold text-gray-700 mb-2'
                                        }, `${example.title} - Coming Soon!`),
                                        React.createElement('p', {
                                            key: 'desc',
                                            className: 'text-gray-500 mb-4'
                                        }, `Interactive ${example.algorithm} visualization is under development.`),
                                        React.createElement('div', {
                                            key: 'features',
                                            className: 'text-sm text-gray-600'
                                        }, [
                                            React.createElement('p', { key: 'p1' }, '‚úÖ Data generation complete'),
                                            React.createElement('p', { key: 'p2' }, 'üîÑ Chart implementation in progress'),
                                            React.createElement('p', { key: 'p3' }, 'üìä Explore the raw data in the Data tab!')
                                        ])
                                    ])
                                }
                            ];
                    }

                    setData(generatedData);
                    setCharts(generatedCharts);
                } catch (error) {
                    console.error('Error generating data for example:', error);
                    setData([]);
                    setCharts([]);
                }
            };

            return React.createElement(MLExamplePage, {
                title: example.title,
                description: example.description,
                algorithm: example.algorithm,
                category: example.category,
                icon: example.icon,
                data: data,
                charts: charts,
                keyPoints: example.keyPoints,
                useCases: example.useCases,
                onBack: onBack
            });
        }

        // ===== RENDER APP =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MLRulesViewer));
    </script>
</body>
</html>